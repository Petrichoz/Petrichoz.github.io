

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="https://p0.itc.cn/q_70/images03/20230516/bab1646e504942d4a9d964cde5d8b15d.jpeg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="pz">
  <meta name="keywords" content="">
  
    <meta name="description" content="第01章 Linux下MySQL的安装与使用1、安装1.1、docker安装12345678docker run -d \-p 3309:3306 \-v &#x2F;atguigu&#x2F;mysql&#x2F;mysql8&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d \-v &#x2F;atguigu&#x2F;mysql&#x2F;mysql8&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-e MYSQL_ROOT_PASSWORD&#x3D;123">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级一">
<meta property="og:url" content="http://example.com/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="PZ">
<meta property="og:description" content="第01章 Linux下MySQL的安装与使用1、安装1.1、docker安装12345678docker run -d \-p 3309:3306 \-v &#x2F;atguigu&#x2F;mysql&#x2F;mysql8&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d \-v &#x2F;atguigu&#x2F;mysql&#x2F;mysql8&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-e MYSQL_ROOT_PASSWORD&#x3D;123">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/mysql.jpg">
<meta property="article:published_time" content="2023-04-28T08:35:21.000Z">
<meta property="article:modified_time" content="2024-11-18T02:51:19.264Z">
<meta property="article:author" content="pz">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/mysql.jpg">
  
  
  
  <title>MySQL高级一 - PZ</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PZ</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL高级一"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-28 16:35" pubdate>
          2023年4月28日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          149 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MySQL高级一</h1>
            
            
              <div class="markdown-body">
                
                <!--

![](timg.jpg)

-->

<hr>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/timg.jpg" srcset="/img/loading.gif" lazyload></p>
<h1 id="第01章-Linux下MySQL的安装与使用"><a href="#第01章-Linux下MySQL的安装与使用" class="headerlink" title="第01章 Linux下MySQL的安装与使用"></a>第01章 Linux下MySQL的安装与使用</h1><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><h3 id="1-1、docker安装"><a href="#1-1、docker安装" class="headerlink" title="1.1、docker安装"></a>1.1、docker安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>-p 3309:3306 \<br>-v /atguigu/mysql/mysql8/conf:/etc/mysql/conf.d \<br>-v /atguigu/mysql/mysql8/data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>--name atguigu-mysql8 \<br>--restart=always \<br>mysql:8.0.30<br></code></pre></td></tr></table></figure>



<h3 id="1-2、查看是否启动"><a href="#1-2、查看是否启动" class="headerlink" title="1.2、查看是否启动"></a>1.2、查看是否启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps<br></code></pre></td></tr></table></figure>



<h3 id="1-3、测试远程链接"><a href="#1-3、测试远程链接" class="headerlink" title="1.3、测试远程链接"></a>1.3、测试远程链接</h3><p><strong>测试连接：</strong>MySQL 8 版本，图形连接时还会出现如下问题</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220625232225259.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220625232225259.png)

-->

<p>配置新连接报错：错误号码 2058，出现这个原因是MySQL 8 之前的版本中加密规则是mysql_native_password，而在MySQL 8之后，加密规则是caching_sha2_password。</p>
<p>解决方案有两种，一种是升级SQLyog和Navicat（因此，新版SQLyog和Navicat不会出现此问题），另一种是把MySQL用户登录密码加密规则还原成mysql_native_password。</p>
<p><strong>解决方法：</strong>登录你的 MySQL 数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入容器：<span class="hljs-built_in">env</span> LANG=C.UTF-8 避免容器中显示中文乱码</span><br>docker exec -it atguigu-mysql8 env LANG=C.UTF-8 /bin/bash<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入容器内的mysql命令行</span><br>mysql -uroot -p<br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改默认密码校验方式</span><br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure>

<p>然后再重新配置SQLyog的连接，重新填写密码，则可连接成功了。 </p>
<h2 id="2、字符集"><a href="#2、字符集" class="headerlink" title="2、字符集"></a>2、字符集</h2><blockquote>
<p>Docker情况下安装的MySQL如何修改配置文件</p>
<ul>
<li>在<code>/atguigu/mysql/mysql8/conf</code> 下随便建一个 <code>xxx.cnf</code> 的文件，默认就是配置文件</li>
<li>字符编码等所有修改都直接改这个文件即可</li>
</ul>
</blockquote>
<h3 id="2-1、默认字符集"><a href="#2-1、默认字符集" class="headerlink" title="2.1、默认字符集"></a>2.1、默认字符集</h3><p><code>MySQL 8版本之前</code>，默认字符集为 latin1（ISO-8859-1） ，不支持中文，使用前必须设置字符集为utf8（utf8mb3）或utf8mb4。从MySQL 8开始，数据库的默认字符集为 utf8mb4 ，从而避免中文乱码的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%char%&#x27;</span>;<br></code></pre></td></tr></table></figure>



<h3 id="2-2、utf8与utf8mb4"><a href="#2-2、utf8与utf8mb4" class="headerlink" title="2.2、utf8与utf8mb4"></a>2.2、utf8与utf8mb4</h3><p>utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而字符集表示一个字符所用的最大字节长度，在某些方面会影响系统的存储和性能，所以设计MySQL的设计者偷偷的定义了两个概念：</p>
<p><strong>utf8mb3 ：</strong>阉割过的 utf8 字符集，只使用1～3个字节表示字符。（无法存储emoji表情）</p>
<p>MySQL5.7中的utf8是utf8mb3字符集</p>
<p><strong>utf8mb4 ：</strong>正宗的 utf8 字符集，使用1～4个字节表示字符。</p>
<p>MySQL8.0中的utf8是utf8mb4字符集</p>
<h2 id="3、-SQL大小写规范"><a href="#3、-SQL大小写规范" class="headerlink" title="3、 SQL大小写规范"></a>3、 SQL大小写规范</h2><h3 id="3-1、Windows和Linux的区别"><a href="#3-1、Windows和Linux的区别" class="headerlink" title="3.1、Windows和Linux的区别"></a>3.1、Windows和Linux的区别</h3><p><strong>Windows环境：</strong></p>
<p>全部不区分大小写</p>
<p><strong>Linux环境：</strong></p>
<p>1、数据库名、表名、表的别名、变量名<code>严格区分大小写</code>；</p>
<p>2、列名与列的别名<code>不区分大小写</code>。</p>
<p>3、关键字、函数名称<code>不区分大小写</code>；</p>
<h3 id="3-2、Linux下大小写规则设置（了解）"><a href="#3-2、Linux下大小写规则设置（了解）" class="headerlink" title="3.2、Linux下大小写规则设置（了解）"></a>3.2、Linux下大小写规则设置（了解）</h3><p>在MySQL 8中设置的具体步骤为：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1、停止MySQL服务 <br>2、删除数据目录，即删除 <span class="hljs-string">/var/lib/mysql</span> 目录 <br>3、在MySQL配置文件（<span class="hljs-string">/etc/my.cnf</span> ）的 [mysqld] 中添加 lower_case_table_names=1 <br>4、初始化数据目录 mysqld <span class="hljs-params">--initialize</span> <span class="hljs-params">--user=mysql</span><br>5、启动MySQL服务 systemctl start mysqld<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：不建议在开发过程中修改此参数，将会丢失所有数据</p>
</blockquote>
<h1 id="第02章-逻辑架构"><a href="#第02章-逻辑架构" class="headerlink" title="第02章 逻辑架构"></a>第02章 逻辑架构</h1><h2 id="1、逻辑架构剖析"><a href="#1、逻辑架构剖析" class="headerlink" title="1、逻辑架构剖析"></a>1、逻辑架构剖析</h2><h3 id="1-1、服务器处理客户端请求"><a href="#1-1、服务器处理客户端请求" class="headerlink" title="1.1、服务器处理客户端请求"></a>1.1、服务器处理客户端请求</h3><p>下面是MySQL5.7使用的<code>经典架构图</code>，MySQL 8中去掉了Caches&amp;Buffers部分：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/b7a8eb46-1168-434c-b63b-ec775affab7b.jpg" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/b7a8eb46-1168-434c-b63b-ec775affab7b.jpg)

-->



<h3 id="1-2、Connectors（客户端）"><a href="#1-2、Connectors（客户端）" class="headerlink" title="1.2、Connectors（客户端）"></a>1.2、Connectors（客户端）</h3><p>MySQL服务器之外的客户端程序，与具体的语言相关，例如Java中的JDBC，图形用户界面SQLyog等。<code>本质上都是在TCP连接上通过MySQL协议和MySQL服务器进行通信。</code></p>
<h3 id="1-3、MySQL-Server（服务器）"><a href="#1-3、MySQL-Server（服务器）" class="headerlink" title="1.3、MySQL Server（服务器）"></a>1.3、MySQL Server（服务器）</h3><h4 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a><strong>第1层：连接层</strong></h4><ul>
<li>客户端访问 MySQL 服务器前，做的<code>第一件事就是建立 TCP 连接</code>。</li>
<li>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做<code>身份认证、权限获取</code>。<ul>
<li>用户名或密码不对<code>，会收到一个</code>Access denied for user<code>错误，客户端程序结束执行</code></li>
<li><code>用户名密码认证通过</code>，会从权限表<code>查出账号拥有的权限</code>与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li>
</ul>
</li>
<li>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</li>
</ul>
<h4 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a><strong>第2层：服务层</strong></h4><p><strong>Management Serveices &amp; Utilities： 系统管理和控制工具</strong></p>
<p><strong>SQL Interface：SQL接口：</strong></p>
<ul>
<li><code>接收用户的SQL命令，并且返回用户需要查询的结果。</code>比如SELECT … FROM就是调用SQL Interface </li>
<li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li>
</ul>
<p><strong>Parser：解析器：</strong></p>
<p>在SQL命令传递到解析器的时候会被解析器验证和解析。解析器中SQL 语句进行<code>词法分析、语法分析、语义分析</code>，并为其创建<code>语法树</code>。</p>
<ul>
<li><p>词法分析：将整个语句拆分成一个个字段</p>
</li>
<li><p>语法分析：将词法分析拆分出的字段，按照MySQl语法规则，生成解析树</p>
</li>
<li><p>语义分析：<code>检查解析树是否合法</code>，比如查看表是否存在，列是否存在</p>
</li>
</ul>
<p>典型的解析树如下：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702002430362.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702002430362.png)

-->



<p><strong>Optimizer：查询优化器：</strong></p>
<ul>
<li>SQL语句在语法解析后、查询前会使用查询优化器对查询进行优化，<code>确定SQL语句的执行路径，生成一个执行计划</code>。</li>
</ul>
<p><strong>Caches &amp; Buffers： 查询缓存组件：</strong></p>
<ul>
<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、查询优化和执行的整个过程了，直接将结果反馈给客户端。</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>
<li>这个查询缓存可以在不同客户端之间共享 。 </li>
<li><strong>问：大多数情况查询缓存就是个鸡肋，为什么呢？</strong><ul>
<li>只有相同的SQL语句才会命中查询缓存。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。</li>
<li>在两条查询之间 有 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句也会导致缓存失效</li>
<li>因此 MySQL的查询缓存命中率不高。<code>所以在MySQL 8之后就抛弃了这个功能。</code></li>
</ul>
</li>
</ul>
<h4 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a><strong>第3层：引擎层</strong></h4><p>存储引擎层（ Storage Engines），<code>负责MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信</code>。不同的存储引擎具有的功能不同，管理的表有不同的存储结构，采用的存取算法也不同，这样我们可以根据自己的实际需要进行选取。例如MyISAM引擎和InnoDB引擎。</p>
<h3 id="1-4、存储层"><a href="#1-4、存储层" class="headerlink" title="1.4、存储层"></a>1.4、存储层</h3><p>所有的数据、数据库、表的定义、表的每一行的内容、索引，都是存在<code>文件系统</code> 上，以文件的方式存在，并完成与存储引擎的交互。</p>
<h3 id="1-5、查询流程说明"><a href="#1-5、查询流程说明" class="headerlink" title="1.5、查询流程说明"></a>1.5、查询流程说明</h3><p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220914161040788.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220914161040788.png)

-->

<p><strong>首先，</strong><code>MySQL客户端通过协议与MySQL服务器建连接，通过SQL接口发送SQL语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析。</code>也就是说，在解析查询之前，服务器会先访问查询缓存，如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</p>
<p><strong>接下来是解析过程，</strong><code>MySQL解析器通过关键字将SQL语句进行解析，并生成一棵对应的解析树，</code>解析器使用MySQL语法规则验证和解析SQL语句。例如，它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确，引号能否前后匹配等；<code>预处理器则根据MySQL规则进一步检查解析树是否合法，</code>例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看是否有歧义等<code>，并生成一棵新解析树</code>，新解析树可能和旧解析树结构一致。</p>
<p><strong>然后是优化过程，</strong><code>MySQL优化程序会对我们的语句做一些优化，将查询的IO成本和CPU成本降到最低。优化的结果就是生成一个执行计划。</code>这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，必要时将子查询转换为连接、表达式简化等等。我们可以使用EXPLAIN语句来查看某个语句的执行计划。</p>
<p><strong>最后，</strong><code>进入执行阶段。</code>完成查询优化后，<code>查询执行引擎</code>会按照生成的执行计划调用存储引擎提供的接口执行SQL查询并将结果返回给客户端。在MySQL8以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存，再返回给客户端。</p>
<h2 id="2、SQL执行流程"><a href="#2、SQL执行流程" class="headerlink" title="2、SQL执行流程"></a>2、SQL执行流程</h2><p>利用<code>SHOW VARIABLES</code> 可以查看SQL的执行流程。使用前需要先开启该功能：</p>
<h3 id="2-1、MySQL8"><a href="#2-1、MySQL8" class="headerlink" title="2.1、MySQL8"></a>2.1、MySQL8</h3><blockquote>
<p>直接观察navicat的剖析即可</p>
</blockquote>
<p><code>1.开启profiling</code></p>
<p>确认profiling是否开启</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%profiling%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702072007905.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702072007905.png)

-->

<p>profiling&#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- profiling = ON</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702073213225.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702073213225.png)

-->



<p><code>2.显示查询</code></p>
<p>执行任意SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> atguigudb.employee; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> atguigudb.employee <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; <br></code></pre></td></tr></table></figure>

<p>显示最近的几次查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILES;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702074559798.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702074559798.png)

-->



<p><code>3.查看执行流程</code></p>
<p><strong>查看最后一个SQL的执行流程：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILE;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702080919952.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702080919952.png)

-->



<p><strong>查看指定SQL的执行流程：查询指定的 Query ID</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILE <span class="hljs-keyword">FOR</span> QUERY <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<p><strong>查询更丰富的内容：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILE cpu,block io <span class="hljs-keyword">FOR</span> QUERY <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220702080407463.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220702080407463.png)

-->

<ul>
<li>SHOW PROFILE 的常用查询参数:<ul>
<li><ul>
<li><p>①ALL：显示所有的开销信息。</p>
</li>
<li><p><code>②BLOCK IO：显示块IO开销。</code></p>
</li>
<li><p>③CONTEXT SWITCHES：上下文切换开销。</p>
</li>
<li><p><code>④CPU：显示CPU开销信息。</code></p>
</li>
<li><p>⑤IPC：显示发送和接收开销信息。</p>
</li>
<li><p>⑥MEMORY：显示内存开销信息。</p>
</li>
<li><p>⑦PAGE FAULTS：显示页面错误开销信息。</p>
</li>
<li><p>⑧SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。</p>
</li>
<li><p>⑨SWAPS：显示交换次数开销信息。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2、MySQL5-7（了解）"><a href="#2-2、MySQL5-7（了解）" class="headerlink" title="2.2、MySQL5.7（了解）"></a>2.2、MySQL5.7（了解）</h3><p><code>1. 查看查询缓存是否启用</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span>;<br></code></pre></td></tr></table></figure>



<p><code>2. 开启查询缓存</code></p>
<p>修改配置文件：vim &#x2F;etc&#x2F;my.cnf<br>新增一行：query_cache_type&#x3D;1<br>重启MySQL：systemctl restart mysqld</p>
<p><code>3. 执行SQL并查看执行流程</code></p>
<p>参考MySQl8中执行流程的启用和查看方式，在MySQL5.7中查看执行流程</p>
<ul>
<li>第一次执行查询SQL：</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220703162615147.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220703162615147.png)

-->



<ul>
<li>第二次执行相同的SQL：</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220703162803963.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220703162803963.png)

-->





<h2 id="3、存储引擎"><a href="#3、存储引擎" class="headerlink" title="3、存储引擎"></a>3、存储引擎</h2><h3 id="3-1、查看存储引擎"><a href="#3-1、查看存储引擎" class="headerlink" title="3.1、查看存储引擎"></a>3.1、查看存储引擎</h3><p>查看MySQL提供什么存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br></code></pre></td></tr></table></figure>

<p>下面的结果表示MySQL中默认使用的存储引擎是InnoDB，支持事务，行锁，外键，支持分布式事务(XA)，支持保存点(回滚)</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220703164220030.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220703164220030.png)

-->



<p>也可以通过以下语句查看默认的存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%default_storage_engine%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220703170334348.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220703170334348.png)

-->



<h3 id="3-2、设置存储引擎（了解）"><a href="#3-2、设置存储引擎（了解）" class="headerlink" title="3.2、设置存储引擎（了解）"></a>3.2、设置存储引擎（了解）</h3><p><code>方法1：</code></p>
<p>设置默认存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="hljs-operator">=</span>MyISAM;<br></code></pre></td></tr></table></figure>



<p><code>方法2：</code></p>
<p>或者修改 my.cnf 文件：vim &#x2F;etc&#x2F;my.cnf<br>在[mysqld]节点下新增一行：default-storage-engine&#x3D;MyISAM<br>重启MySQL：systemctl restart mysqld</p>
<p><code>方法3：</code></p>
<p>我们可以为 不同的表设置不同的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名( 建表语句 ) ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br><br><span class="hljs-comment">-- 例如：</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(id <span class="hljs-type">INT</span>, `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>),age <span class="hljs-type">INT</span>,dept <span class="hljs-type">INT</span>) ENGINE <span class="hljs-operator">=</span> MyISAM;<br></code></pre></td></tr></table></figure>



<h3 id="3-3、各种引擎介绍"><a href="#3-3、各种引擎介绍" class="headerlink" title="3.3、各种引擎介绍"></a>3.3、各种引擎介绍</h3><p><code>1. InnoDB存储引擎</code></p>
<ul>
<li><p>InnoDB是MySQL的默认事务型引擎，它被设计用来<code>处理大量的短期(short-lived)事务</code>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p>
</li>
<li><p>除非有非常特别的原因需要使用其他的存储引擎，否则<code>应该优先考虑InnoDB引擎</code>。</p>
</li>
<li><p>InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p>
</li>
</ul>
<p><code>2. MyISAM存储引擎</code></p>
<ul>
<li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但<code>MyISAM不支持事务和行级锁</code>，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
</li>
<li><p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用。</p>
</li>
<li><p>MyISAM只缓存索引，不缓存真实数据。</p>
</li>
</ul>
<p><code>3. Archive引擎</code></p>
<ul>
<li><code>Archive档案存储引擎只支持INSERT和SELECT操作</code>。</li>
<li>Archive表适合日志和数据采集（档案）类应用。</li>
<li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li>
</ul>
<p><code>4. Blackhole引擎（黑洞）</code></p>
<ul>
<li><code>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存</code>。</li>
<li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li>
</ul>
<p><code>5. CSV引擎</code> </p>
<ul>
<li><code>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引</code>。</li>
<li>CSV引擎可以作为一种数据交换的机制，非常有用。</li>
<li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li>
</ul>
<p><code>6. Memory引擎</code></p>
<ul>
<li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li>
<li>Memory表至少比MyISAM表要快一个数量级。</li>
</ul>
<p><code>7. Federated引擎</code></p>
<ul>
<li><code>Federated引擎是访问其他MySQL服务器的一个代理（跨库关联查询）</code>，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ul>
<h3 id="3-4、MyISAM和InnoDB的区别"><a href="#3-4、MyISAM和InnoDB的区别" class="headerlink" title="3.4、MyISAM和InnoDB的区别"></a>3.4、MyISAM和InnoDB的区别</h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。支持聚簇索引</td>
</tr>
<tr>
<td>关注点</td>
<td>并发查询，节省资源、消耗少、简单业务</td>
<td>并发写、事务、更大更复杂的资源操作</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<h1 id="第03章-SQL预热"><a href="#第03章-SQL预热" class="headerlink" title="第03章 SQL预热"></a>第03章 SQL预热</h1><blockquote>
<p>课下练习：50道SQL复杂查询</p>
</blockquote>
<h2 id="1、创建测试数据"><a href="#1、创建测试数据" class="headerlink" title="1、创建测试数据"></a>1、创建测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_dept` (<br> `id` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br> `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>);<br> <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp` (<br> `id` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br> `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `age` <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br> `deptId` <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br> <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br> KEY `idx_dept_id` (`deptId`)<br> #<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;华山&#x27;</span>,<span class="hljs-string">&#x27;华山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;丐帮&#x27;</span>,<span class="hljs-string">&#x27;洛阳&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;峨眉&#x27;</span>,<span class="hljs-string">&#x27;峨眉山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;武当&#x27;</span>,<span class="hljs-string">&#x27;武当山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;明教&#x27;</span>,<span class="hljs-string">&#x27;光明顶&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(id,deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;少林&#x27;</span>,<span class="hljs-string">&#x27;少林寺&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;风清扬&#x27;</span>,<span class="hljs-number">90</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100001</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;岳不群&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100002</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;令狐冲&#x27;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100003</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;洪七公&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100004</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100005</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;灭绝师太&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100006</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;周芷若&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100007</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;张三丰&#x27;</span>,<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100008</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">100009</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(id,NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;韦小宝&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">100010</span>);<br></code></pre></td></tr></table></figure>



<h2 id="2、常见七种JOIN查询"><a href="#2、常见七种JOIN查询" class="headerlink" title="2、常见七种JOIN查询"></a>2、常见七种JOIN查询</h2><p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/af2eb76c-a503-4845-8fd4-3f7cd3441831.jpg" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/af2eb76c-a503-4845-8fd4-3f7cd3441831.jpg)

-->





<p><strong>需求1：</strong>查询<code>所有有部门的员工</code>信息以及他所在的部门信息</p>
<p>在A、和B中都存在的数据 &#x3D;&gt; <code>查询A、B两表交集</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure>



<p><strong>需求2：</strong>查询<code>所有用户</code>，并显示其部门信息（如果员工没有所在部门，也会被列出） &#x3D;&gt; <code>查询A的全集</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure>



<p><strong>需求3：</strong>列出<code>所有部门</code>，并显示其部门的员工信息（如果部门没有员工，也会被列出）&#x3D;&gt; <code>查询B的全集</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure>



<p><strong>需求4：</strong>查询<code>没有加入任何部门的员工</code>（先查询所有员工，再过滤掉包含部门的数据） &#x3D;&gt; <code>查询A且不包含B</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure>



<p><strong>需求5：</strong>查询<code>没有任何员工的部门</code> &#x3D;&gt; <code>查询B且不包含A</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">WHERE</span> a.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure>



<p><strong>需求6：</strong>查询<code>所有员工和所有部门</code> &#x3D;&gt; <code>AB全有</code></p>
<p>MySQL FULL JOIN 的实现：因为MySQL不支持FULL JOIN，下面是替代方法</p>
<p>LEFT JOIN + UNION(合并并去重) + RIGHT JOIN</p>
<blockquote>
<p>注意：</p>
<ul>
<li>UNION和UNION ALL要求字段数量和顺序都一致</li>
<li>如果确定两表结果不会重复，则使用UNION ALL提升效率</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">UNION</span> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure>



<p><strong>需求7：</strong>查询<code>没有加入任何部门的员工</code>，以及查询出部门下<code>没有任何员工的部门</code> &#x3D;&gt; <code>A的独有+B的独有</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <br><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> t_emp a <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptid <span class="hljs-operator">=</span> b.id <br><span class="hljs-keyword">WHERE</span> a.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure>



<h2 id="3、扩展掌门人"><a href="#3、扩展掌门人" class="headerlink" title="3、扩展掌门人"></a>3、扩展掌门人</h2><h3 id="3-1、增加掌门人字段"><a href="#3-1、增加掌门人字段" class="headerlink" title="3.1、增加掌门人字段"></a>3.1、增加掌门人字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t_dept <span class="hljs-keyword">ADD</span> CEO <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>);<br><span class="hljs-keyword">UPDATE</span> t_dept <span class="hljs-keyword">SET</span> CEO<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> t_dept <span class="hljs-keyword">SET</span> CEO<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">UPDATE</span> t_dept <span class="hljs-keyword">SET</span> CEO<span class="hljs-operator">=</span><span class="hljs-number">6</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br><span class="hljs-keyword">UPDATE</span> t_dept <span class="hljs-keyword">SET</span> CEO<span class="hljs-operator">=</span><span class="hljs-number">8</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">4</span>;<br><span class="hljs-keyword">UPDATE</span> t_dept <span class="hljs-keyword">SET</span> CEO<span class="hljs-operator">=</span><span class="hljs-number">9</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>



<h3 id="3-2、练习"><a href="#3-2、练习" class="headerlink" title="3.2、练习"></a>3.2、练习</h3><p><strong>需求1：</strong>求各个门派对应的掌门人</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> b.deptname, a.name <span class="hljs-keyword">FROM</span> t_dept b <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_emp a <span class="hljs-keyword">ON</span> b.ceo <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure>



<p><strong>需求2：</strong>求所有掌门人的平均年龄</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(a.age) <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.id <span class="hljs-operator">=</span> b.ceo;<br></code></pre></td></tr></table></figure>



<p><strong>需求3：</strong>求所有人物对应的掌门名称（4种写法分析）</p>
<ul>
<li>三表左连接方式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 员工表(t_emp)、部门表(t_dept)、ceo(t_emp)表 关联查询</span><br><span class="hljs-keyword">SELECT</span> emp.name, ceo.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> t_emp emp<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_emp ceo <span class="hljs-keyword">ON</span> dept.ceo <span class="hljs-operator">=</span> ceo.id;<br></code></pre></td></tr></table></figure>

<ul>
<li>子查询方式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>emp.name, <br>(<span class="hljs-keyword">SELECT</span> ceo.name <span class="hljs-keyword">FROM</span> t_emp ceo <span class="hljs-keyword">WHERE</span> ceo.id <span class="hljs-operator">=</span> dept.ceo) <span class="hljs-keyword">AS</span> ceoname<br><span class="hljs-keyword">FROM</span> t_emp emp<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id<br></code></pre></td></tr></table></figure>

<ul>
<li>临时表连接方式1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_with_ceo_id.name, emp.name <span class="hljs-keyword">AS</span> ceoname <span class="hljs-keyword">FROM</span> <br><span class="hljs-comment">-- 查询所有员工及对应的ceo的id</span><br>( <br><span class="hljs-keyword">SELECT</span> emp.name, dept.ceo <br><span class="hljs-keyword">FROM</span> t_emp emp <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id <br>) emp_with_ceo_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_emp emp <span class="hljs-keyword">ON</span> emp_with_ceo_id.ceo <span class="hljs-operator">=</span> emp.id;<br></code></pre></td></tr></table></figure>

<ul>
<li>临时表连接方式2</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp.name, ceo.ceoname <span class="hljs-keyword">FROM</span> t_emp emp <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br><span class="hljs-comment">-- 查询并创建临时表ceo：包含ceo的部门id和ceo的name</span><br>( <br><span class="hljs-keyword">SELECT</span> emp.deptId <span class="hljs-keyword">AS</span> deptId, emp.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> t_emp emp <br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.id <span class="hljs-operator">=</span> dept.ceo <br>) ceo<br><span class="hljs-keyword">ON</span> emp.deptId <span class="hljs-operator">=</span> ceo.deptId;<br></code></pre></td></tr></table></figure>



<h1 id="第04章-MySQL索引"><a href="#第04章-MySQL索引" class="headerlink" title="第04章 MySQL索引"></a>第04章 MySQL索引</h1><h2 id="1、索引简介"><a href="#1、索引简介" class="headerlink" title="1、索引简介"></a>1、索引简介</h2><h3 id="1-1、什么是索引☆"><a href="#1-1、什么是索引☆" class="headerlink" title="1.1、什么是索引☆"></a>1.1、什么是索引<strong>☆</strong></h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。</strong><br><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为<code>“排好序的快速查找数据结构”</code>。这些数据结构以某种方式指向数据， 可以在这些数据结构的基础上实现高级查找算法 。</p>
<h3 id="1-2、索引的优缺点☆"><a href="#1-2、索引的优缺点☆" class="headerlink" title="1.2、索引的优缺点☆"></a>1.2、索引的优缺点<strong>☆</strong></h3><p><strong>优点：</strong></p>
<p>（1）<code>提高数据检索的效率，降低数据库的IO成本</code><br>（2）保证表中每条记录的<code>唯一性</code> 。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220704024203535.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220704024203535.png)

-->



<p><strong>缺点：</strong><br>（1）创建索引和维护索引要<code>耗费时间</code> 。<br>（2）索引是存储在磁盘上的，因此需要<code>占用磁盘空间</code> 。 </p>
<h3 id="1-3、索引分类☆"><a href="#1-3、索引分类☆" class="headerlink" title="1.3、索引分类☆"></a>1.3、索引分类<strong>☆</strong></h3><ul>
<li>从功能逻辑上划分，索引主要有 4 种，分别是<code>普通索引、唯一索引、主键索引、全文索引</code>。</li>
<li>按照作用字段个数划分，索引可以分为<code>单列索引和联合索引</code>。</li>
<li>按照物理实现方式划分 ，索引可以分为 2 种，分别是<code>聚簇索引和非聚簇索引</code>。</li>
</ul>
<h2 id="2、树"><a href="#2、树" class="headerlink" title="2、树"></a>2、树</h2><h3 id="2-1、二叉树"><a href="#2-1、二叉树" class="headerlink" title="2.1、二叉树"></a>2.1、二叉树</h3><p><strong>二叉树</strong></p>
<p>树有很多种，每个节点<code>最多</code>只能有<code>两个子节点</code>的一种形式称为二叉树。二叉树的子节点分为左节点和右节点。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220805121226057.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220805121226057.png)

-->



<p><strong>二叉搜索树BST</strong></p>
<p><code>BST(Binary Sort(Search) Tree)：</code>对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p>
<p><code>特别说明：</code>如果有相同的值，可以将该节点放在左子节点或右子节点。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220708231318868.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220708231318868.png)

-->

<p>BST的生成演示：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BST.html">https://www.cs.usfca.edu/~galles/visualization/BST.html</a></p>
<p> 下图就是<code>一种可能的索引方式示例</code>：</p>
<ul>
<li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址：</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220704025815748.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220704025815748.png)

-->

<ul>
<li>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找获取到相应数据，从而快速的检索出符合条件的记录：</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220704025257848.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220704025257848.png)

-->



<p><strong>BST的问题</strong></p>
<ul>
<li>上面演示的实际上是一个特殊的<code>二叉搜索树</code>，叫做<code>平衡 二叉搜索树</code>，  如果二叉树不平衡，例如左子树全部为空，从形式上看，更像一个单链表，不能发挥BST的优势。</li>
<li><code>解决方案：平衡二叉树(AVL)</code></li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220708231622916.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220708231622916.png)

-->



<p><strong>平衡二叉树（AVL）</strong></p>
<p>AVL树全称G.M. <code>A</code>delson-<code>V</code>elsky和E.M. <code>L</code>andis，这是两个人的人名。</p>
<p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</p>
<p><code>具有以下特点：</code></p>
<ul>
<li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</li>
<li>并且左右两个子树都是一棵平衡二叉树。</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220708235509010.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220708235509010.png)

-->

<p>AVL的生成演示：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a></p>
<p><strong>AVL的问题</strong></p>
<p>众所周知，IO操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐节点加载（一个节点一次IO）。如果我们利用二叉树作为索引结构，<code>那么磁盘的IO次数和索引树的高度是相关的</code>。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220708233351509.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220708233351509.png)

-->

<p>为了提高查询效率，就需要 减少磁盘IO数 。<code>为了减少磁盘IO的次数，就需要尽量降低树的高度</code> ，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三叉树：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220708235725124.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220708235725124.png)

-->

<p>上面的例子中，我们将二叉树变成了三叉树，降低了树的高度。<code>如果能够在一个节点中存放更多的数据</code>，我们还可以进一步减少节点的数量，从而进一步降低树的高度。这就是<code>多叉树</code>。</p>
<h3 id="2-2、B树"><a href="#2-2、B树" class="headerlink" title="2.2、B树"></a>2.2、B树</h3><ul>
<li><code>B-Tree即B树，Balance Tree，平衡树,B树就是典型的多叉树，它的高度远小于平衡二叉树的高度</code>。</li>
<li><code>B树的阶：</code>节点的最多子节点个数。</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709054736482.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709054736482.png)

-->

<p>上图所表示的 B 树就是一棵 3 阶的 B 树。假设一个磁盘块可以存储一个节点的数据。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，三节点的子树的值大小仍然遵守 BST 二叉排序树的规则。</p>
<p><code>假设我们想要 查找的数据项是 9 ，那么步骤可以分为以下几步：</code></p>
<ol>
<li>第一次磁盘IO：找到根节点磁盘块1，读入内存，执行二分查找，9 小于 17 ，得到指针 P1； </li>
<li>第二次磁盘IO：按照指针P1找到磁盘块 2，读入内存，执行二分查找， 9 在 8 和 12 之间，得到指针 P2； </li>
<li>第三次磁盘IO：按照指针P2找到磁盘块 6，读入内存，执行二分查找， 找到了数据项 9。</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。<code>而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。</code> B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ，在数据查询中比平衡二叉树效率要高。<code>所以只要树的高度足够低，IO次数足够少，就可以提高查询性能</code> 。</p>
<p><strong>再举例：</strong></p>
<p><code>假设</code>使用B树作为索引结构，存放MySQL中的数据：</p>
<p><code>蓝色</code>部分表示数据的主键，<code>黄色</code>部分表示除主键外的其他数据，<code>紫色</code>部分表示指向子节点的指针</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709075255638.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709075255638.png)

-->



<h2 id="3、MySQL的索引结构：B-tree"><a href="#3、MySQL的索引结构：B-tree" class="headerlink" title="3、MySQL的索引结构：B+tree"></a>3、MySQL的索引结构：B+tree</h2><h3 id="3-1、InnoDB中的索引"><a href="#3-1、InnoDB中的索引" class="headerlink" title="3.1、InnoDB中的索引"></a>3.1、InnoDB中的索引</h3><h4 id="3-1-1、设计索引"><a href="#3-1-1、设计索引" class="headerlink" title="3.1.1、设计索引"></a>3.1.1、设计索引</h4><p>假设有一个表index_demo，表中有2个INT类型的列，1个CHAR(1)类型的列，c1列为主键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(c1 <span class="hljs-type">INT</span>,c2 <span class="hljs-type">INT</span>,c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">PRIMARY</span> KEY(c1)) ;<br></code></pre></td></tr></table></figure>



<p>index_demo表的简化的行格式示意图如下：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709071958145.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709071958145.png)

-->



<ul>
<li><code>record_type：</code>表示记录的类型， 0是普通记录、 2是最小记录、 3 是最大记录、1是B+树非叶子节点记录。</li>
<li><code>next_record：</code>表示下一条记录的相对位置，我们用箭头来表明下一条记录。</li>
<li><code>各个列的值：</code>这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
</ul>
<p>把一些记录放到页里的示意图就是<code>（这里一页就是一个磁盘块，代表一次IO）</code>：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709072138395.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709072138395.png)

-->



<p><code>MySQL InnoDB的默认的页大小是16KB</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看默认页的大小</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Innodb_page_size&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711220407169.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711220407169.png)

-->



<p>因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中的记录没有规律，我们就不得不依次遍历所有的数据页。<code>如果我们想快速的定位到需要查找的记录在哪些数据页中</code>，我们可以这样做 ：</p>
<ul>
<li><code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</code></li>
<li>给所有的页建立目录项</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709073749310.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709073749310.png)

-->

<p>以<code>页28</code>为例，它对应<code>目录项2</code> ，这个目录项中包含着该页的<code>页号28</code>以及该页中用户记录的<code>最小主键值 5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。<code>比如：查找主键值为 20 的记录，具体查找过程分两步：</code></p>
<ol>
<li>先从目录项中根据二分法快速确定出<code>主键值为20的记录在目录项3中</code>（因为 12 ≤ 20 &lt; 209 ），<code>对应页9</code>。 </li>
<li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code> 。 </p>
<h4 id="3-1-2、InnoDB中的索引方案"><a href="#3-1-2、InnoDB中的索引方案" class="headerlink" title="3.1.2、InnoDB中的索引方案"></a>3.1.2、InnoDB中的索引方案</h4><p>我们新分配一个编号为30的页来专门存储<code>目录项记录</code>，页10、28、9、20专门存储<code>用户记录</code>： </p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709074801215.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709074801215.png)

-->

<p><code>目录项记录和普通的用户记录的不同点：</code> </p>
<ul>
<li>目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。</li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，包含很多列，另外还有InnoDB自己添加的隐藏列。</li>
</ul>
<p><code>现在查找主键值为 20 的记录，具体查找过程分两步：</code></p>
<ol>
<li>先到页30中通过二分法快速定位到对应目录项，因为 12 ≤ 20 &lt; 209 ，就是页9。 </li>
<li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li>
</ol>
<p><strong>更复杂的情况如下：</strong></p>
<p>我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <code>[1, 320)</code> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。<strong>这个数据结构，它的名称是 B+树 。</strong> </p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709080648851.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709080648851.png)

-->



<h3 id="3-2、B树和B-树对比☆"><a href="#3-2、B树和B-树对比☆" class="headerlink" title="3.2、B树和B+树对比☆"></a>3.2、B树和B+树对比<strong>☆</strong></h3><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p>
<ul>
<li><p>B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中， 非叶子节点既保存索引，也保存数据记录 。 </p>
</li>
<li><p>B+树中所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>
</li>
<li><p>B+树中非叶子节点的关键字也会同时存在于子节点中，并且是在子节点中所有关键字的最小值。</p>
</li>
</ul>
<p><strong>B+树为什么IO的次数会更少：</strong></p>
<ul>
<li><code>真实环境</code>中一个页存放的记录数量是非常大的（默认16KB），假设指针与键值占大约10字节，数据占 1 kb 的空间：</li>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，则最多能存放 16 条记录。</li>
<li>如果B+树有2层，最多能存放约 <code>1600×16=25600</code> 条记录。</li>
<li>如果B+树有3层，最多能存放约 <code>1600×1600×16=40960000</code> 条记录。</li>
<li>如果存储千万级别的数据，只需要三层就够了</li>
</ul>
<p><code>B+树的非叶子节点不存储用户记录，只存储目录记录，相对B树每个节点可以存储更多的记录，树的高度会更矮胖，IO次数也会更少。</code></p>
<h3 id="3-3、聚簇索引☆"><a href="#3-3、聚簇索引☆" class="headerlink" title="3.3、聚簇索引☆"></a>3.3、聚簇索引<strong>☆</strong></h3><p><strong>特点：</strong></p>
<ul>
<li><p><code>索引和数据保存在同一个B+树中</code></p>
</li>
<li><p><code>页内的记录</code>是按照<code>主键</code>的大小顺序排成一个<code>单向链表</code> 。</p>
</li>
<li><p><code>页和页之间</code>也是根据页中记录的<code>主键</code>的大小顺序排成一个<code>双向链表</code> 。</p>
</li>
<li><p>非叶子节点存储的是记录的<code>主键+页号</code>。</p>
</li>
<li><p>叶子节点存储的是<code>完整的用户记录</code>。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>数据访问更快 ，因为<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快。</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于<code>数据都是紧密相连</code>，数据库可以从更少的数据块中提取数据，<code>节省了大量的IO操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code>。</li>
<li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<code>主键为不可更新</code>。</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>只有InnoDB引擎支持聚簇索引，<code>MyISAM不支持聚簇索引</code>。</li>
<li>由于数据的物理存储排序方式只能有一种，所以<code>每个MySQL的表只能有一个聚簇索引</code>。</li>
<li>如果没有为表定义主键，InnoDB会选择<code>非空的唯一索引列代替</code>。如果没有这样的列，InnoDB会<code>隐式的定义一个主键</code>作为聚簇索引。</li>
<li>为了充分利用聚簇索引的聚簇特性，InnoDB中表的<code>主键应选择有序的id</code>，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。</li>
</ul>
<h3 id="3-4、非聚簇索引☆"><a href="#3-4、非聚簇索引☆" class="headerlink" title="3.4、非聚簇索引☆"></a>3.4、非聚簇索引<strong>☆</strong></h3><p><strong>（二级索引、辅助索引）</strong></p>
<p><code>聚簇索引</code>，只能在搜索条件是<code>主键值</code>时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建<code>非聚簇索引</code>。</p>
<p><strong>例如，</strong><code>以c2列作为搜索条件</code>，那么需要使<code>用c2列创建一棵B+树</code>，如下所示：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709130937991.png" srcset="/img/loading.gif" lazyload>&#96;</p>
<!--

![](MySQL8高级-架构和优化/image-20220709130937991.png)

-->



<p><strong>这个B+树与聚簇索引有几处不同：</strong></p>
<ul>
<li><p><code>页内的记录</code>是按照从<code>c2列</code>的大小顺序排成一个<code>单向链表</code> 。</p>
</li>
<li><p><code>页和页之间</code>也是根据页中记录的<code>c2列</code>的大小顺序排成一个<code>双向链表</code> 。</p>
</li>
<li><p>非叶子节点存储的是记录的<code>c2列+页号</code>。</p>
</li>
<li><p>叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</p>
</li>
</ul>
<p><strong>例如：</strong>根据c2列的值查找c2&#x3D;4的记录，查找过程如下：</p>
<ol>
<li>根据<code>根页面44</code>定位到<code>页42</code>（因为<code>2 ≤  4 &lt; 9</code>）</li>
<li>由于<code>c2列没有唯一性约束</code>，所以c2&#x3D;4的记录可能分布在多个数据页中，又因为 <code>2 ≤ 4  ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34和页35</code>中。</li>
<li>在页34和35中<code>定位到具体的记录</code>。</li>
<li>但是这个B+树的叶子节点<code>只存储了c2和c1（主键）</code>两个列，所以我们必须<code>再根据主键值去聚簇索引中再查找</code>一遍完整的用户记录。</li>
</ol>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220714101340016.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220714101340016.png)

-->

<p><strong>概念：回表</strong> </p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表 。也就是根据c2列的值查询一条完整的用户记录需要<code>使用到 2棵B+树</code>！</p>
<p><strong>问题：</strong></p>
<p>为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p><strong>回答：</strong><br>如果把完整的用户记录放到叶子节点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p><strong>一张表可以有多个非聚簇索引：</strong></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709134109900.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709134109900.png)

-->



<h3 id="3-5、联合索引"><a href="#3-5、联合索引" class="headerlink" title="3.5、联合索引"></a>3.5、联合索引</h3><p><code>为c2和c3列建立联合索引：</code></p>
<ul>
<li>各个页中的记录按照<code>c2</code>列进行排序。</li>
<li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li>
<li>B+树叶子节点处的记录由<code>c2列、c3列和主键c1列组成</code></li>
<li>本质上也是二级索引</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712002627554.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712002627554.png)

-->



<h3 id="3-6、覆盖索引☆"><a href="#3-6、覆盖索引☆" class="headerlink" title="3.6、覆盖索引☆"></a>3.6、覆盖索引<strong>☆</strong></h3><p>如果能通过读取索引就可以得到想要的数据，那就不需要读取用户记录，或者<code>不用再做回表</code>操作了。<code>一个索引包含了满足查询结果的数据就叫做覆盖索引。</code> </p>
<p>例如，如果为前面例子中的数据库表创建c2列索引，则如下SQL会使用覆盖索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># C1 主键 c2 普通索引<br><span class="hljs-keyword">SELECT</span> c1, c2 <span class="hljs-keyword">from</span> index_demo <span class="hljs-keyword">where</span> c2 <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>



<h3 id="3-7、MyISAM中的索引☆"><a href="#3-7、MyISAM中的索引☆" class="headerlink" title="3.7、MyISAM中的索引☆"></a>3.7、MyISAM中的索引<strong>☆</strong></h3><p>MyISAM引擎使用 B+Tree 作为索引结构，<code>叶子节点的data域存放的是数据记录的地址</code> 。 </p>
<p>下图是MyISAM索引的原理图<code>（索引和数据分开存储，是非聚簇索引）</code>： </p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709180255597.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709180255597.png)

-->



<p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示<code>（是非聚簇索引）</code>：</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709180605148.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709180605148.png)

-->



<h3 id="3-8、MyISAM与InnoDB对比☆"><a href="#3-8、MyISAM与InnoDB对比☆" class="headerlink" title="3.8、MyISAM与InnoDB对比☆"></a>3.8、MyISAM与InnoDB对比<strong>☆</strong></h3><ul>
<li><p>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的：</p>
<ul>
<li>InnoDB的表在磁盘上存储在以下文件中： <code>.ibd（表结构、索引和数据都存在一起,MySQL5.7表结构放在.frm中）</code></li>
<li>MyISAM的表在磁盘上存储在以下文件中：  <code>*.sdi（描述表结构，MySQL5.7是.frm）</code>、<code>*.MYD（数据）</code>，<code>*.MYI（索引）</code></li>
</ul>
</li>
<li><p>InnoDB中主键索引是聚簇索引，叶子节点中存储完整的数据记录；其他索引是非聚簇索引，存储相应记录主键的值 。</p>
</li>
<li><p>InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以<code>非空且唯一</code>标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。</p>
</li>
<li><p>MyISAM中无论是主键索引还是非主键索引都是非聚簇的，叶子节点记录的是数据的地址。</p>
</li>
<li><p><code>MyISAM的回表操作是十分快速的</code>，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
</li>
</ul>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709183820796.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709183820796.png)

-->



<h2 id="4、索引操作"><a href="#4、索引操作" class="headerlink" title="4、索引操作"></a>4、索引操作</h2><h3 id="4-1、创建索引"><a href="#4-1、创建索引" class="headerlink" title="4.1、创建索引"></a>4.1、创建索引</h3><ul>
<li>随表一起创建索引：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>    <br>  id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT,<br>  customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>  customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>    <br>  <span class="hljs-keyword">PRIMARY</span> KEY(id), <span class="hljs-comment">-- 主键索引：列设定为主键后会自动建立索引，唯一且不能为空。</span><br>  <span class="hljs-keyword">UNIQUE</span> INDEX uk_no (customer_no), <span class="hljs-comment">-- 唯一索引：索引列值必须唯一，允许有NULL值，且NULL可能会出现多次。</span><br>  KEY idx_name (customer_name), <span class="hljs-comment">-- 普通索引：既不是主键，列值也不需要唯一，单纯的为了提高查询速度而创建。</span><br>  KEY idx_no_name (customer_no,customer_name) <span class="hljs-comment">-- 复合索引：即一个索引包含多个列。</span><br>);<br></code></pre></td></tr></table></figure>



<ul>
<li>单独建创索引：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer1 (<br>  id <span class="hljs-type">INT</span> UNSIGNED,<br>  customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>  customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>)<br>);<br><br><span class="hljs-comment">-- 建表后创建索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY customer1(id); <span class="hljs-comment">-- 主键索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX uk_no <span class="hljs-keyword">ON</span> customer1(customer_no); <span class="hljs-comment">-- 唯一索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> customer1(customer_name);  <span class="hljs-comment">-- 普通索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_no_name <span class="hljs-keyword">ON</span> customer1(customer_no,customer_name); <span class="hljs-comment">-- 复合索引</span><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 MODIFY id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT, <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY customer1(id); <span class="hljs-comment">--创建自增的主键索引</span><br></code></pre></td></tr></table></figure>



<ul>
<li>使用ALTER命令：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id); <span class="hljs-comment">-- 主键索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> INDEX uk_no (customer_no); <span class="hljs-comment">-- 唯一索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">ADD</span> INDEX idx_name (customer_name);   <span class="hljs-comment">-- 普通索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">ADD</span> INDEX idx_no_name (customer_no,customer_name);  <span class="hljs-comment">-- 复合索引</span><br></code></pre></td></tr></table></figure>



<h3 id="4-2、查看索引"><a href="#4-2、查看索引" class="headerlink" title="4.2、查看索引"></a>4.2、查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> customer;<br></code></pre></td></tr></table></figure>



<h3 id="4-3、删除索引"><a href="#4-3、删除索引" class="headerlink" title="4.3、删除索引"></a>4.3、删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_name <span class="hljs-keyword">ON</span> customer; <span class="hljs-comment">-- 删除单值、唯一、复合索引</span><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer MODIFY id <span class="hljs-type">INT</span> UNSIGNED, <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY; <span class="hljs-comment">-- 删除主键索引(有主键自增)</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer1 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;  <span class="hljs-comment">-- 删除主键索引(没有主键自增)</span><br></code></pre></td></tr></table></figure>



<h2 id="5、索引的使用场景☆"><a href="#5、索引的使用场景☆" class="headerlink" title="5、索引的使用场景☆"></a>5、索引的使用场景<strong>☆</strong></h2><p><strong>哪些情况适合创建索引：</strong></p>
<ul>
<li>频繁作为WHERE查询条件的字段     id &#x3D; 聚簇索引，不需要回表 iphone</li>
<li>经常GROUP BY 和 ORDER BY的列    </li>
<li>字段的值有唯一性的限制 </li>
<li>DISTINCT字段需要创建索引</li>
<li>多表JOIN时，对连接字段创建索引</li>
<li>使用字符串前缀创建索引<ul>
<li><code>例如</code>一个字段 address varchar（120），我们可以创建索引的长度为（12）个字符，节省索引空间</li>
</ul>
</li>
<li>区分度高的列（重复的数据少）适合作为索引</li>
<li>使用频繁的列，放到联合索引的左侧</li>
</ul>
<p><strong>哪些情况不要创建索引：</strong></p>
<ul>
<li>WHERE、GROUP BY 、ORDER BY里用不到的字段不创建索引</li>
<li>表的数据记录太少</li>
<li>有大量重复数据的列上 </li>
<li>避免对经常增删改的表创建索引 </li>
<li>不要定义冗余或重复的索引</li>
</ul>
<h1 id="第05章-索引优化"><a href="#第05章-索引优化" class="headerlink" title="第05章 索引优化"></a>第05章 索引优化</h1><h2 id="1、数据库优化方案"><a href="#1、数据库优化方案" class="headerlink" title="1、数据库优化方案"></a>1、数据库优化方案</h2><p><strong>问题：</strong></p>
<p>哪些方法可以进行数据库调优？</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>索引失效，没有充分利用到索引：<code>索引建立</code></p>
</li>
<li><p>关联查询太多JOIN（设计缺陷或不得已的需求）：<code>SQL优化</code></p>
</li>
<li><p>数据过多500W，2GB：分库分表</p>
</li>
<li><p>服务器调优及各个参数设置（缓冲、线程数等）：调整my.cnf</p>
</li>
</ul>
<h2 id="2、性能分析（EXPLAIN）"><a href="#2、性能分析（EXPLAIN）" class="headerlink" title="2、性能分析（EXPLAIN）"></a>2、性能分析（EXPLAIN）</h2><h3 id="2-1、EXPLAIN是什么"><a href="#2-1、EXPLAIN是什么" class="headerlink" title="2.1、EXPLAIN是什么"></a>2.1、EXPLAIN是什么</h3><p>查看SQL执行计划：使用EXPLAIN关键字可以<code>模拟优化器执行SQL查询语句</code>，从而知道MySQL是如何处理你的SQL语句的。<code>分析你的查询语句或是表结构的性能瓶颈</code>。</p>
<p><strong>用法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-operator">+</span> <span class="hljs-keyword">SQL</span>语句<br></code></pre></td></tr></table></figure>



<h3 id="2-2、数据准备"><a href="#2-2、数据准备" class="headerlink" title="2.2、数据准备"></a>2.2、数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE atguigudb;<br> <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT, content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT, content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t3(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT, content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t4(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT, content1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span>, content2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><br><span class="hljs-keyword">CREATE</span> INDEX idx_content1 <span class="hljs-keyword">ON</span> t4(content1);  <span class="hljs-comment">-- 创建普通索引</span><br><br># 以下新增<span class="hljs-keyword">sql</span>多执行几次，以便演示<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t1_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t2_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t3(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t3_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t4(content1, content2) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t4_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)), CONCAT(<span class="hljs-string">&#x27;t4_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br></code></pre></td></tr></table></figure>



<h3 id="2-3、各字段解释"><a href="#2-3、各字段解释" class="headerlink" title="2.3、各字段解释"></a>2.3、各字段解释</h3><h4 id="2-3-1、id"><a href="#2-3-1、id" class="headerlink" title="2.3.1、id"></a>2.3.1、id</h4><p>在一个完整的查询语句中，每个SELECT关键字，都对应一个唯一的id。同时通过id也可以知道操作表的顺序。</p>
<ul>
<li><strong>id相同：</strong>一个SELECT，id都是1</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2, t3;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710000757241.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710000757241.png)

-->



<ul>
<li><strong>id不同：</strong>三个SELECT，id是1、2、3</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> t1.id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span>(<br>  <span class="hljs-keyword">SELECT</span> t2.id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t2.id <span class="hljs-operator">=</span>(<br>    <span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3 <span class="hljs-keyword">WHERE</span> t3.content <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;000&#x27;</span><br>  )<br>);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806204009208.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806204009208.png)

-->

<p><strong>注意：</strong>如果t3表查询无结果，则table列<code>t1</code>和<code>t2</code>处为<code>NULL</code></p>
<p><strong>注意：</strong>查询优化器可能对涉及子查询的语句进行优化，<code>转为连接查询</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> content <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> content <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> content <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711123408605.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711123408605.png)

-->



<ul>
<li><strong>id为NULL：</strong>把t1和t2的查询结果合并，并创建名为&lt;union1,2&gt;的临时表，然后对结果去重</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t2;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710001512891.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710001512891.png)

-->

<p>因此包含UNION ALL的执行计划中就没有这条记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t2;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806205841029.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806205841029.png)

-->



<p><strong>小结：</strong></p>
<ul>
<li>id如果相同，可以认为是一组，<code>从上往下顺序执行</code></li>
<li>在所有组中，<code>id值越大，越先执行</code></li>
<li>关注点：每个id号码，表示一趟独立的查询, <code>一个sql的查询趟数越少越好</code></li>
</ul>
<h4 id="2-3-2、table"><a href="#2-3-2、table" class="headerlink" title="2.3.2、table"></a>2.3.2、table</h4><ul>
<li><strong>单表：</strong>显示这一行的数据是关于哪张表的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710101402666.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710101402666.png)

-->

<ul>
<li><strong>多表：</strong>关联查询中，显示在执行计划第一行的是驱动表，第二行是被驱动表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">EXPLAIN SELECT * FROM t1, t2 WHERE t1.id = t2.id;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220807014004193.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220807014004193.png)

-->



<h4 id="2-3-5、type-☆"><a href="#2-3-5、type-☆" class="headerlink" title="2.3.5、type ☆"></a>2.3.5、type <strong>☆</strong></h4><blockquote>
<p><strong>说明：</strong></p>
<p>结果值从最好到最坏依次是： </p>
<p><code>system &gt; const &gt; eq_ref &gt; ref</code> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <code>range &gt; index &gt; ALL</code> </p>
<p><code>比较重要的包含：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></p>
<p>SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，最好是 <code>const</code>级别。（阿里巴巴<br>开发手册要求）</p>
</blockquote>
<ul>
<li><strong>ALL：</strong>全表扫描。Full Table Scan，将遍历全表以找到匹配的行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712065946659.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712065946659.png)

-->



<ul>
<li><strong>index：</strong>全索引扫描。当使用<code>覆盖索引</code>，但需要扫描<code>全部的索引记录</code>时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> content1 <span class="hljs-keyword">FROM</span> t4;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806200359943.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806200359943.png)

-->

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t1;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712065815768.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712065815768.png)

-->



<ul>
<li><strong>range：</strong>只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806211954646.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806211954646.png)

-->



<ul>
<li><strong>ref：</strong>通过普通二级索引列与常量进行等值匹配时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t4 <span class="hljs-keyword">WHERE</span> content1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806212137124.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806212137124.png)

-->



<ul>
<li><p><strong>eq_ref：</strong>连接查询时通过<code>主键</code>或不允许NULL值的<code>唯一二级索引</code>列进行等值匹配时 <strong>?</strong> </p>
<p>数据量级，可能会影响索引的使用！ mysql 内部的优化器！</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712070851089.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712070851089.png)

-->



<ul>
<li><strong>const：</strong>根据<code>主键</code>或者<code>唯一二级索引</code>列与<code>常数</code>进行匹配时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712070944090.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712070944090.png)

-->



<ul>
<li><strong>system：</strong>MyISAM引擎中，当表中只有一条记录时。<code>（这是所有type的值中性能最高的场景）</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t(i <span class="hljs-type">int</span>) Engine<span class="hljs-operator">=</span>MyISAM;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>);<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711125730163.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711125730163.png)

-->



<h4 id="2-3-6、possible-keys-和-key-☆"><a href="#2-3-6、possible-keys-和-key-☆" class="headerlink" title="2.3.6、possible_keys 和 key ☆"></a>2.3.6、possible_keys 和 key <strong>☆</strong></h4><ul>
<li><p><code>possible_keys</code>表示执行查询时<code>可能用到的索引</code>，一个或多个。 查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
</li>
<li><p><code>keys</code>表示<code>实际使用的索引</code>。如果为NULL，则没有使用索引。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710142152514.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710142152514.png)

-->



<h4 id="2-3-7、key-len-☆"><a href="#2-3-7、key-len-☆" class="headerlink" title="2.3.7、key_len ☆"></a>2.3.7、key_len <strong>☆</strong></h4><p>表示索引使用的字节数，根据这个值可以判断索引的使用情况，<code>检查是否充分利用了索引，针对联合索引值越大越好。</code></p>
<p><strong>如何计算：</strong></p>
<ol>
<li>先看索引上字段的类型+长度。比如：int&#x3D;4 ; varchar(20) &#x3D;20 ; char(20) &#x3D;20 </li>
<li>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf8要乘 3(MySQL5.7)，如果是utf8mb4要乘4，GBK要乘2</li>
<li>varchar这种动态字符串要加2个字节</li>
<li>允许为空的字段要加1个字节</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age_name <span class="hljs-keyword">ON</span> t_emp(age, `name`);<br><span class="hljs-comment">-- 测试1</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ab%&#x27;</span>;<br><span class="hljs-comment">-- 测试2</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710130548971.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710130548971.png)

-->



<h4 id="2-3-8、ref"><a href="#2-3-8、ref" class="headerlink" title="2.3.8、ref"></a>2.3.8、ref</h4><p>显示与key中的索引进行比较的列或常量。</p>
<ul>
<li><strong>const：</strong>  与索引列进行等值比较的东西是啥，const表示一个常数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t4 <span class="hljs-keyword">WHERE</span> content1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806213843328.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806213843328.png)

-->



<ul>
<li><strong>ref&#x3D;atguigudb.t1.id</strong>   关联查询时出现，t2表和t1表的哪一列进行关联</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220806214146640.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220806214146640.png)

-->



<h4 id="2-3-9、rows-☆"><a href="#2-3-9、rows-☆" class="headerlink" title="2.3.9、rows ☆"></a>2.3.9、rows <strong>☆</strong></h4><p>MySQL认为它执行查询时实际从索引树中查找到的行数。<code>值越小越好。</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 如果是全表扫描，rows的值就是表中数据的估计行数</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;100001&#x27;</span>;<br><br><span class="hljs-comment">-- 如果是使用索引查询，rows的值就是预计扫描索引记录行数</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710131916240.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710131916240.png)

-->



<h4 id="2-3-10、filtered"><a href="#2-3-10、filtered" class="headerlink" title="2.3.10、filtered"></a>2.3.10、filtered</h4><p>最后查询出来的数据占所有服务器端（server）检查行数（rows）的<code>百分比</code>。<code>值越大越好</code>。</p>
<p>例如上一个例子。</p>
<h4 id="2-3-11、Extra-☆"><a href="#2-3-11、Extra-☆" class="headerlink" title="2.3.11、Extra ☆"></a>2.3.11、Extra <strong>☆</strong></h4><p>包含不适合在其他列中显示但十分重要的额外信息。通过这些额外信息来<code>理解MySQL到底将如何执行当前的查询语句</code>。MySQL提供的额外信息有好几十个，这里只挑比较重要的介绍。</p>
<ul>
<li><strong>Using where：</strong>使用了where，但在where上有字段没有创建索引。也可以理解为如果数据从引擎层被返回到server层进行过滤，那么就是Using where。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220709215122017.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220709215122017.png)

-->



<ul>
<li><strong>Using filesort：</strong></li>
</ul>
<p>如果出现了Using filesort 说明排序没有使用上索引，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710172607190.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710172607190.png)

-->

<p>如果排序操作无法使用到索引，只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序（filesort），如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> content;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710172926396.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710172926396.png)

-->



<ul>
<li><strong>Using index：</strong><code>使用了覆盖索引</code>，表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id, content1 <span class="hljs-keyword">FROM</span> t4;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712071716131.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712071716131.png)

-->



<ul>
<li><strong>Using index condition：</strong>叫作  <code>Index Condition Pushdown Optimization （索引下推优化）</code><ul>
<li><code>如果没有索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给server层，server层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li>
<li><code>如果使用了索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 &gt; &#39;z&#39; AND content1 LIKE &#39;%a&#39;</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给server层。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- content1列上有索引idx_content1</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t4 <span class="hljs-keyword">WHERE</span> content1 <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-keyword">AND</span> content1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710180257692.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710180257692.png)

-->

<p><strong>注意：</strong>如果这里的查询条件<code>只有content1 &gt; &#39;z&#39;</code>，那么找到满足条件的索引后也会进行一次索引下推的操作，判断content1 &gt; ‘z’是否成立（这是源码中为了编程方便做的冗余判断）</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712012108900.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712012108900.png)

-->



<ul>
<li><strong>Using join buffer：</strong>在连接查询时，当<code>被驱动表（t2）不能有效的利用索引时</code>，MySQL会提前申请一块内存空间（join buffer）存储驱动表的数据，来加快查询速度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.content <span class="hljs-operator">=</span> t2.content;<br># 创建了索引就不会出现<span class="hljs-keyword">Using</span> <span class="hljs-keyword">join</span> buffer！<br><span class="hljs-keyword">create</span> index idx_content <span class="hljs-keyword">on</span> t2(content);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710182356817.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710182356817.png)

-->

<p>下面这个例子就是被驱动表使用了索引，此时Extra中就没有Using join buffer了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp, t_dept <span class="hljs-keyword">WHERE</span> t_dept.id <span class="hljs-operator">=</span> t_emp.deptId;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710182524371.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710182524371.png)

-->



<blockquote>
<p><code>课外阅读：</code>在没有索引的情况下，为了优化多表连接，减少磁盘IO读取次数和数据遍历次数，MySQL为我们提供了很多不同的连接缓存的优化算法，可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35423190/article/details/120504960">https://blog.csdn.net/qq_35423190/article/details/120504960</a></p>
<ul>
<li><code>Using join buffer (hash join)</code><strong>8.0新增：</strong>连接缓存（hash连接） <code>速度更快</code></li>
<li><code>Using join buffer (Block Nested Loop)</code><strong>从5.7开始</strong>：连接缓存（块嵌套循环）</li>
</ul>
</blockquote>
<h2 id="3、准备数据"><a href="#3、准备数据" class="headerlink" title="3、准备数据"></a>3、准备数据</h2><p>在做优化之前，要准备大量数据。接下来创建两张表，并往员工表里插入50W数据，部门表中插入1W条数据。</p>
<p>怎么快速插入50w条数据呢？ <code>存储过程</code></p>
<p>怎么保证插入的数据不重复？<code>函数</code></p>
<p><strong>部门表：</strong></p>
<ul>
<li><p>id：自增长</p>
</li>
<li><p>deptName：随机字符串，允许重复</p>
</li>
<li><p>address：随机字符串，允许重复</p>
</li>
<li><p>CEO：1-50w之间的任意数字</p>
</li>
</ul>
<p><strong>员工表：</strong></p>
<ul>
<li>id：自增长</li>
<li>empno：可以使用随机数字，或者<code>从1开始的自增数字</code>，不允许重复</li>
<li>name：随机生成，允许姓名重复</li>
<li>age：区间随机数</li>
<li>deptId：1-1w之间随机数</li>
</ul>
<p><strong>总结：</strong>需要产生随机字符串和区间随机数的函数。</p>
<h3 id="3-1、创建表"><a href="#3-1、创建表" class="headerlink" title="3.1、创建表"></a>3.1、创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `dept` (<br>	`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>	`deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>	`address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>	ceo <span class="hljs-type">INT</span> <span class="hljs-keyword">NULL</span> ,<br>	<span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (<br>	`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>	`empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>	`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>	`age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>	`deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>	<span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>	#<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>



<h3 id="3-2、创建函数"><a href="#3-2、创建函数" class="headerlink" title="3.2、创建函数"></a>3.2、创建函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看mysql是否允许创建函数：</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_bin_trust_function_creators&#x27;</span>;<br><span class="hljs-comment">-- 命令开启：允许创建函数设置：（global-所有session都生效）</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_bin_trust_function_creators<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 随机产生字符串</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>)<br><span class="hljs-keyword">BEGIN</span>    <br>	<span class="hljs-keyword">DECLARE</span> chars_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br>	<span class="hljs-keyword">DECLARE</span> return_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>	<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	WHILE i <span class="hljs-operator">&lt;</span> n DO  <br>		<span class="hljs-keyword">SET</span> return_str <span class="hljs-operator">=</span>CONCAT(return_str,<span class="hljs-built_in">SUBSTRING</span>(chars_str,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">52</span>),<span class="hljs-number">1</span>));  <br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">RETURN</span> return_str;<br><span class="hljs-keyword">END</span> $$<br><br><span class="hljs-comment">-- 假如要删除</span><br><span class="hljs-comment">-- drop function rand_string;</span><br></code></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 用于随机产生区间数字</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_num (from_num <span class="hljs-type">INT</span> ,to_num <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)<br><span class="hljs-keyword">BEGIN</span>   <br> <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-built_in">FLOOR</span>(from_num <span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span>(to_num <span class="hljs-operator">-</span>from_num<span class="hljs-operator">+</span><span class="hljs-number">1</span>));<br><span class="hljs-keyword">RETURN</span> i;  <br><span class="hljs-keyword">END</span>$$<br><br><span class="hljs-comment">-- 假如要删除</span><br><span class="hljs-comment">-- drop function rand_num;</span><br></code></pre></td></tr></table></figure>



<h3 id="3-3、创建存储过程"><a href="#3-3、创建存储过程" class="headerlink" title="3.3、创建存储过程"></a>3.3、创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入员工数据</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span>  insert_emp(<span class="hljs-keyword">START</span> <span class="hljs-type">INT</span>, max_num <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span>  <br>	<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;   <br>	#<span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span><span class="hljs-number">0</span> 把autocommit设置成<span class="hljs-number">0</span>  <br>	<span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <br>	REPEAT  <br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;  <br>		<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (empno, NAME, age, deptid ) <span class="hljs-keyword">VALUES</span> ((<span class="hljs-keyword">START</span><span class="hljs-operator">+</span>i) ,rand_string(<span class="hljs-number">6</span>), rand_num(<span class="hljs-number">30</span>,<span class="hljs-number">50</span>), rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>));  <br>		UNTIL i <span class="hljs-operator">=</span> max_num  <br>	<span class="hljs-keyword">END</span> REPEAT;  <br>	<span class="hljs-keyword">COMMIT</span>;  <br><span class="hljs-keyword">END</span>$$<br> <br><span class="hljs-comment">-- 删除</span><br><span class="hljs-comment">-- DELIMITER ;</span><br><span class="hljs-comment">-- drop PROCEDURE insert_emp;</span><br></code></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-comment">-- 插入部门数据</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_dept(max_num <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span>  <br>	<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;   <br>	<span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <br>	REPEAT  <br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;  <br>		<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept ( deptname,address,ceo ) <span class="hljs-keyword">VALUES</span> (rand_string(<span class="hljs-number">8</span>),rand_string(<span class="hljs-number">10</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>));  <br>		UNTIL i <span class="hljs-operator">=</span> max_num  <br>	<span class="hljs-keyword">END</span> REPEAT;  <br>	<span class="hljs-keyword">COMMIT</span>;  <br><span class="hljs-keyword">END</span>$$<br> <br><span class="hljs-comment">-- 删除</span><br><span class="hljs-comment">-- DELIMITER ;</span><br><span class="hljs-comment">-- drop PROCEDURE insert_dept;</span><br></code></pre></td></tr></table></figure>



<h3 id="3-4、调用存储过程"><a href="#3-4、调用存储过程" class="headerlink" title="3.4、调用存储过程"></a>3.4、调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 执行存储过程，往dept表添加1万条数据</span><br><span class="hljs-keyword">CALL</span> insert_dept(<span class="hljs-number">10000</span>); <br><br><span class="hljs-comment">-- 执行存储过程，往emp表添加50万条数据，编号从100000开始</span><br><span class="hljs-keyword">CALL</span> insert_emp(<span class="hljs-number">100000</span>,<span class="hljs-number">500000</span>); <br></code></pre></td></tr></table></figure>



<h3 id="3-5、批量删除表索引"><a href="#3-5、批量删除表索引" class="headerlink" title="3.5、批量删除表索引"></a>3.5、批量删除表索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 批量删除某个表上的所有索引 建议使用可视化工具执行</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),tablename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>))<br><span class="hljs-keyword">BEGIN</span><br>	<span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">DECLARE</span> ct <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">DECLARE</span> _index <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>	<span class="hljs-keyword">DECLARE</span> _cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> index_name <span class="hljs-keyword">FROM</span> information_schema.STATISTICS <span class="hljs-keyword">WHERE</span> table_schema<span class="hljs-operator">=</span>dbname <span class="hljs-keyword">AND</span> table_name<span class="hljs-operator">=</span>tablename <span class="hljs-keyword">AND</span> seq_in_index<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> index_name <span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;PRIMARY&#x27;</span>  ;<br>	<span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> done<span class="hljs-operator">=</span><span class="hljs-number">2</span> ;      <br>	<span class="hljs-keyword">OPEN</span> _cur;<br>		<span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;<br>		WHILE  _index<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;&#x27;</span> DO <br>			<span class="hljs-keyword">SET</span> <span class="hljs-variable">@str</span> <span class="hljs-operator">=</span> CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename ); <br>			<span class="hljs-keyword">PREPARE</span> sql_str <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@str</span> ;<br>			<span class="hljs-keyword">EXECUTE</span> sql_str;<br>			<span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> sql_str;<br>			<span class="hljs-keyword">SET</span> _index<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>; <br>			<span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index; <br>		<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">CLOSE</span> _cur;<br><span class="hljs-keyword">END</span>$$<br></code></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 执行批量删除：dbname 库名称, tablename 表名称</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;); <br></code></pre></td></tr></table></figure>



<h3 id="3-6、开启SQL执行时间的显示"><a href="#3-6、开启SQL执行时间的显示" class="headerlink" title="3.6、开启SQL执行时间的显示"></a>3.6、开启SQL执行时间的显示</h3><p><code>为了方便后面的测试中随时查看SQL运行的时间，测试索引优化后的效果，我们开启profiling</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 显示sql语句执行时间</span><br><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES  <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%profiling%&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> PROFILES;<br></code></pre></td></tr></table></figure>



<h2 id="4、单表索引失效案例"><a href="#4、单表索引失效案例" class="headerlink" title="4、单表索引失效案例"></a>4、单表索引失效案例</h2><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<p><strong>我们创建索引后，用不用索引，最终是优化器说了算。<code>优化器会基于开销选择索引，怎么开销小就怎么来。</code>不是基于规则，也不是基于语义。</strong></p>
<p><strong>另外SQL语句是否使用索引，和数据库的版本、数据量、数据选择度（查询中选择的列数）运行环境都有关系。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> emp(`name`);<br></code></pre></td></tr></table></figure>



<h3 id="4-1、计算、函数导致索引失效"><a href="#4-1、计算、函数导致索引失效" class="headerlink" title="4.1、计算、函数导致索引失效"></a>4.1、计算、函数导致索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 显示查询分析</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name  <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;abc%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(emp.name,<span class="hljs-number">3</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">--索引失效</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710212756603.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710212756603.png)

-->



<h3 id="4-2、LIKE以-开头索引失效"><a href="#4-2、LIKE以-开头索引失效" class="headerlink" title="4.2、LIKE以%开头索引失效"></a>4.2、LIKE以%开头索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%ab%&#x27;</span>; <span class="hljs-comment">--索引失效</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710213641577.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710213641577.png)

-->

<blockquote>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 电商中全文检索es 不应该mysql</p>
</blockquote>
<h3 id="4-3、不等于-或者-索引失效"><a href="#4-3、不等于-或者-索引失效" class="headerlink" title="4.3、不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>4.3、不等于(!&#x3D; 或者&lt;&gt;)索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abc&#x27;</span> ;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;abc&#x27;</span> ; <span class="hljs-comment">--索引失效</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710214317491.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710214317491.png)

-->



<h3 id="4-4、IS-NOT-NULL-和-IS-NULL"><a href="#4-4、IS-NOT-NULL-和-IS-NULL" class="headerlink" title="4.4、IS NOT NULL 和 IS NULL"></a>4.4、IS NOT NULL 和 IS NULL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">--索引失效</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710214840703.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710214840703.png)

-->



<p><strong>注意：</strong>当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span><br><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">SET</span> `name` <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">&gt;</span> <span class="hljs-number">20000</span>;<br><br><span class="hljs-comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span><br><span class="hljs-comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711175040606.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711175040606.png)

-->



<p><strong>测试完将name的值改回来</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">SET</span> `name` <span class="hljs-operator">=</span> rand_string(<span class="hljs-number">6</span>) <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">&gt;</span> <span class="hljs-number">20000</span>;<br></code></pre></td></tr></table></figure>



<h3 id="4-5、类型转换导致索引失效"><a href="#4-5、类型转换导致索引失效" class="headerlink" title="4.5、类型转换导致索引失效"></a>4.5、类型转换导致索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123&#x27;</span>; <br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span> <span class="hljs-number">123</span>; <span class="hljs-comment">--索引失效</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220710215217274.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220710215217274.png)

-->



<h3 id="4-6、全值匹配我最爱"><a href="#4-6、全值匹配我最爱" class="headerlink" title="4.6、全值匹配我最爱"></a>4.6、全值匹配我最爱</h3><p><strong>准备：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先删除之前创建的索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br><span class="hljs-keyword">drop</span> index idx_name <span class="hljs-keyword">on</span> emp;<br></code></pre></td></tr></table></figure>

<p><strong>问题：</strong>为以下查询语句创建哪种索引效率最高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询分析</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> deptid <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-comment">-- 执行SQL</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> deptid <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-comment">-- 查看执行时间</span><br><span class="hljs-keyword">SHOW</span> PROFILES;<br></code></pre></td></tr></table></figure>

<p><strong>创建索引并重新执行以上测试：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引：分别创建以下三种索引的一种，并分别进行以上查询分析</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age <span class="hljs-keyword">ON</span> emp(age);<br><span class="hljs-keyword">CREATE</span> INDEX idx_age_deptid <span class="hljs-keyword">ON</span> emp(age,deptid);<br><span class="hljs-keyword">CREATE</span> INDEX idx_age_deptid_name <span class="hljs-keyword">ON</span> emp(age,deptid,`name`);<br></code></pre></td></tr></table></figure>

<p><strong>结论：</strong>可以发现最高效的查询应用了联合索引 <code>idx_age_deptid_name</code> </p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711190731030.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711190731030.png)

-->



<h3 id="4-7、最佳左前缀法则"><a href="#4-7、最佳左前缀法则" class="headerlink" title="4.7、最佳左前缀法则"></a>4.7、最佳左前缀法则</h3><p><strong>准备：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先删除之前创建的索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age_deptid_name <span class="hljs-keyword">ON</span> emp(age,deptid,`name`);<br></code></pre></td></tr></table></figure>

<p><strong>问题：</strong>以下这些SQL语句能否命中 <code>idx_age_deptid_name</code> 索引，可以匹配多少个索引字段</p>
<p><strong>测试：</strong></p>
<ul>
<li>如果索引了多列，要遵守最左前缀法则。即查询从<code>索引的最左前列</code>开始并且不跳过索引中的列。</li>
<li>过滤条件要使用索引，必须按照<code>索引建立时的顺序，依次满足</code>，一旦跳过某个字段，索引后面的字段都无法被使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.age<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span> ;<br><span class="hljs-comment">-- EXPLAIN结果：</span><br><span class="hljs-comment">-- key_len：5 只使用了age索引</span><br><span class="hljs-comment">-- 索引查找的顺序为 age、deptid、name，查询条件中不包含deptid，无法使用deptid和name索引</span><br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.deptid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-comment">-- EXPLAIN结果：</span><br><span class="hljs-comment">-- type： ALL， 执行了全表扫描</span><br><span class="hljs-comment">-- key_len： NULL， 索引失效</span><br><span class="hljs-comment">-- 索引查找的顺序为 age、deptid、name，查询条件中不包含age，无法使用整个索引</span><br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> emp.deptid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-comment">-- EXPLAIN结果：</span><br><span class="hljs-comment">-- 索引查找的顺序为 age、deptid、name，匹配所有索引字段</span><br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.deptid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abcd&#x27;</span> <span class="hljs-keyword">AND</span> emp.age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- EXPLAIN结果：</span><br><span class="hljs-comment">-- 索引查找的顺序为 age、deptid、name，匹配所有索引字段</span><br></code></pre></td></tr></table></figure>



<h3 id="4-8、索引中范围条件右边的列失效"><a href="#4-8、索引中范围条件右边的列失效" class="headerlink" title="4.8、索引中范围条件右边的列失效"></a>4.8、索引中范围条件右边的列失效</h3><p><strong>准备：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先删除之前创建的索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br></code></pre></td></tr></table></figure>

<p><strong>问题：</strong>为以下查询语句创建哪种索引效率最高</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.age<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> emp.deptId<span class="hljs-operator">&gt;</span><span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> emp.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;abc&#x27;</span>; <br></code></pre></td></tr></table></figure>

<p><strong>测试1：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引并执行以上SQL语句的EXPLAIN</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age_deptid_name <span class="hljs-keyword">ON</span> emp(age,deptid,`name`);<br><span class="hljs-comment">-- key_len：10， 只是用了 age 和 deptid索引，name失效</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong>当我们修改deptId的范围条件的时候，例如deptId&gt;100，那么整个索引失效，MySQL的优化器基于成本计算后认为没必要使用索引了，所以就进行了全表扫描。<code>（注意：因为表中的数据是随机生成的，因此实际测试中根据具体数据的不同测试的结果也会不一样，最终是否使用索引由优化器决定）</code></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220711215826013.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220711215826013.png)

-->

<p><strong>测试2：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引并执行以上SQL语句的EXPLAIN（将deptid索引的放在最后）</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age_name_deptid <span class="hljs-keyword">ON</span> emp(age,`name`,deptid);<br><span class="hljs-comment">-- 使用了完整的索引</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712080350120.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712080350120.png)

-->

<p><strong>补充：</strong>以上两个索引都存在的时候，MySQL优化器会自动选择最好的方案</p>
<h2 id="5、关联查询优化"><a href="#5、关联查询优化" class="headerlink" title="5、关联查询优化"></a>5、关联查询优化</h2><h3 id="5-1、数据准备"><a href="#5-1、数据准备" class="headerlink" title="5.1、数据准备"></a>5.1、数据准备</h3><p>创建两张表，并分插入16条和20条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 分类</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `class` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>);<br><span class="hljs-comment">-- 图书</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `book` (<br>`bookid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`bookid`)<br>);<br> <br><span class="hljs-comment">-- 插入16条记录</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br> <br><span class="hljs-comment">-- 插入20条记录</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br></code></pre></td></tr></table></figure>



<h3 id="5-2、左外连接"><a href="#5-2、左外连接" class="headerlink" title="5.2、左外连接"></a>5.2、左外连接</h3><p><strong>没有创建索引前的测试：</strong>进行了<code>全表扫描</code>，查询次数为<code>16*20</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br><span class="hljs-comment">-- 左表class：驱动表、右表book：被驱动表</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712194001008.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712194001008.png)

-->

<p><strong>测试1：</strong>在驱动表上创建索引：进行了<code>全索引扫描</code>，查询次数是<code>16*20</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712194239217.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712194239217.png)

-->

<p><strong>测试2：</strong>在被驱动表上创建索引：可以避免全表扫描，查询次数是<code>16*1</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先删除之前创建的索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;class&quot;);<br><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_book_card <span class="hljs-keyword">ON</span> book(card);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712194515757.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712194515757.png)

-->

<p><strong>测试3：</strong>同时给两张表添加索引：充分利用了索引，查询次数是<code>16*1</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 已经有了book索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712194722843.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712194722843.png)

-->

<blockquote>
<p><strong>结论：</strong></p>
<p>针对两张表的连接条件涉及的列，索引要创建在被驱动表上，驱动表尽量是小表</p>
<ul>
<li><p>如果驱动表上没有where过滤条件</p>
<ul>
<li>当驱动表的连接条件没有索引时，驱动表是全表扫描</li>
<li>当针对驱动表的连接条件建立索引时，驱动表依然要进行全索引扫描</li>
<li>因此，此时建立在驱动表上的连接条件上的索引是没有太大意义的</li>
</ul>
</li>
<li><p>如果驱动表上有where过滤条件，那么针对过滤条件创建的索引是有必要的</p>
</li>
</ul>
</blockquote>
<h3 id="5-3、内连接"><a href="#5-3、内连接" class="headerlink" title="5.3、内连接"></a>5.3、内连接</h3><p><strong>测试：</strong>将前面外连接中的LEFT JOIN 变成 INNER JOIN</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 换成inner join</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card<span class="hljs-operator">=</span>book.card;<br><span class="hljs-comment">-- 交换class和book的位置</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> class <span class="hljs-keyword">ON</span> class.card<span class="hljs-operator">=</span>book.card;<br></code></pre></td></tr></table></figure>

<p><strong>都有索引的情况下：</strong>查询优化器自动选择数据量小的表做为驱动表</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712195140151.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712195140151.png)

-->

<p><strong>class表有索引的情况下：</strong>book表是驱动表</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712205137594.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712205137594.png)

-->

<p><strong>book表有索引的情况下：</strong>class表是驱动表</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712204913627.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712204913627.png)

-->

<p><strong>都没有索引的情况下：</strong>选择数据量小的表做为驱动表</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712205030216.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712205030216.png)

-->

<blockquote>
<p><strong>结论：</strong>发现即使交换表的位置，MySQL优化器也会自动选择驱动表，自动选择驱动表的原则是：索引创建在被驱动表上，驱动表是小表。</p>
</blockquote>
<h3 id="5-4、扩展掌门人的练习"><a href="#5-4、扩展掌门人的练习" class="headerlink" title="5.4、扩展掌门人的练习"></a>5.4、扩展掌门人的练习</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先删除之前创建的索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;dept&quot;);<br></code></pre></td></tr></table></figure>



<p><strong>1.三表左连接方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 员工表(t_emp)、部门表(t_dept)、ceo(t_emp)表 关联查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> emp.name, ceo.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> emp<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> emp ceo <span class="hljs-keyword">ON</span> dept.ceo <span class="hljs-operator">=</span> ceo.id;<br></code></pre></td></tr></table></figure>

<p>一趟查询，用到了主键索引，<code>效果最佳</code></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712210059275.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712210059275.png)

-->



<p><strong>2.子查询方式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> emp.name,<br>(<span class="hljs-keyword">SELECT</span> emp.name <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.id <span class="hljs-operator">=</span> dept.ceo) <span class="hljs-keyword">AS</span> ceoname<br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure>

<p>两趟查询，用到了主键索引，<code>跟第一种比，效果稍微差点</code>。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712210641833.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712210641833.png)

-->



<p><strong>3.临时表连接方式</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> emp_with_ceo_id.name, emp.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> <br>( <br><span class="hljs-keyword">SELECT</span> emp.name, dept.ceo <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id <br>) emp_with_ceo_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> emp <span class="hljs-keyword">ON</span> emp_with_ceo_id.ceo <span class="hljs-operator">=</span> emp.id;<br></code></pre></td></tr></table></figure>

<p>查询一趟，<code>MySQL查询优化器将衍生表查询转换成了连接表查询</code>，速度堪比第一种方式</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712211307003.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712211307003.png)

-->

<p><strong>MySQL5.5查询结果：</strong>两趟查询，先查询a,b产生衍生表ab,衍生表作为驱动表，c作为被驱动表，使用到c表主键。效果比后面一种要好一点。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/3c5034f7-69f3-4381-9354-70f4a4220165.jpg" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/3c5034f7-69f3-4381-9354-70f4a4220165.jpg)

-->



<p><strong>4、临时表连接方式2</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> emp.name, ceo.ceoname <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br>( <br><span class="hljs-keyword">SELECT</span> emp.deptId <span class="hljs-keyword">AS</span> deptId, emp.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> emp.id <span class="hljs-operator">=</span> dept.ceo <br>) ceo<br><span class="hljs-keyword">ON</span> emp.deptId <span class="hljs-operator">=</span> ceo.deptId;<br></code></pre></td></tr></table></figure>

<p>查询一趟，<code>MySQL查询优化器将衍生表查询转换成了连接表查询</code>，但是只有一个表使用了索引，数据检索的次数稍多，<code>性能最差</code>。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220712211909850.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220712211909850.png)

-->

<p><strong>MySQL5.5查询结果：</strong>两趟查询，先查询b, a产生衍生表ab,衍生表作为被驱动表，衍生表无法建立索引，也就无法优化; 所以，这种语句是性能最差的。</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/f3725755-bbbf-44da-99c7-20fc04d86c5d.jpg" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/f3725755-bbbf-44da-99c7-20fc04d86c5d.jpg)

-->



<h3 id="5-5、总结"><a href="#5-5、总结" class="headerlink" title="5.5、总结"></a>5.5、总结</h3><ul>
<li><p>保证被驱动表的JOIN字段已经创建了索引。</p>
</li>
<li><p>需要JOIN 的字段，数据类型保持绝对一致。</p>
</li>
<li><p>LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表 。减少外层循环的次数。</p>
</li>
<li><p>INNER JOIN 时，MySQL会自动将小结果集的表选为驱动表 。选择相信MySQL优化策略。</p>
</li>
<li><p>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</p>
</li>
<li><p>衍生表建不了索引（MySQL5.5）</p>
</li>
</ul>
<h2 id="6、子查询优化"><a href="#6、子查询优化" class="headerlink" title="6、子查询优化"></a>6、子查询优化</h2><p><strong>查询非掌门人</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不推荐</span><br><span class="hljs-comment">-- 查询员工，这些员工的id没在（掌门人id列表中）</span><br><span class="hljs-comment">-- 【查询不是CEO的员工】</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp emp <span class="hljs-keyword">WHERE</span> emp.id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> <br>(<span class="hljs-keyword">SELECT</span> dept.ceo <span class="hljs-keyword">FROM</span> t_dept dept <span class="hljs-keyword">WHERE</span> dept.ceo <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220809115231228.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220809115231228.png)

-->



<p>注意：使用大表测试更加直观！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 推荐</span><br><span class="hljs-comment">-- 按照集合查询</span><br><span class="hljs-keyword">SELECT</span> emp.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp emp <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.id <span class="hljs-operator">=</span> dept.ceo <span class="hljs-keyword">WHERE</span> dept.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220809115259956.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220809115259956.png)

-->



<p>也可以为ceo添加一个索引字段</p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220809115203460.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220809115203460.png)

-->



<blockquote>
<p><strong>结论：</strong>尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx &#x3D; xx WHERE xx IS NULL替代</p>
</blockquote>
<h2 id="7、排序优化"><a href="#7、排序优化" class="headerlink" title="7、排序优化"></a>7、排序优化</h2><h3 id="7-1、索引失效的情况"><a href="#7-1、索引失效的情况" class="headerlink" title="7.1、索引失效的情况"></a>7.1、索引失效的情况</h3><blockquote>
<p><strong>以下三种情况不走索引：</strong></p>
<ol>
<li><p>无过滤，不索引</p>
</li>
<li><p>顺序错，不索引</p>
</li>
<li><p>方向反，不索引</p>
</li>
</ol>
</blockquote>
<p><strong>准备：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除现有索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_age_deptid_name <span class="hljs-keyword">ON</span> emp (age,deptid,`name`);<br></code></pre></td></tr></table></figure>

<p><strong>无过滤，不索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 没有使用索引：</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age,deptid;<br><br><span class="hljs-comment">-- 使用了索引：order by想使用索引，必须有过滤条件，索引才能生效，limit也可以看作是过滤条件</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age,deptid LIMIT <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure>

<p><strong>顺序错，不索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序使用了索引：</span><br><span class="hljs-comment">-- 注意：key_len = 5是where语句使用age索引的标记，order by语句使用索引不在key_len中体现。             </span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid;<br><br><span class="hljs-comment">-- 排序使用了索引：</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid, `name`; <br><br><span class="hljs-comment">-- 排序没有使用索引：因为索引列中不存在empno</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid, empno;<br><br><span class="hljs-comment">-- 排序没有使用索引：order by 后的排序条件的顺序，与索引顺序不一致</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `name`, deptid;<br><br><span class="hljs-comment">-- 排序没有使用索引：出现的顺序要和复合索引中的列的顺序一致！</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> deptid<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure>

<p><strong>方向反，不索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序使用了索引：排序条件和索引一致，并方向相同，可以使用索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid <span class="hljs-keyword">DESC</span>, `name` <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 没有使用索引：两个排序条件方向相反</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid <span class="hljs-keyword">ASC</span>, `name` <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure>



<h3 id="7-2、索引优化案例"><a href="#7-2、索引优化案例" class="headerlink" title="7.2、索引优化案例"></a>7.2、索引优化案例</h3><blockquote>
<p>排序优化的目的是，去掉 Extra 中的 using filesort（手工排序）</p>
</blockquote>
<p><strong>准备：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除现有索引</span><br><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;atguigudb&quot;,&quot;emp&quot;);<br><span class="hljs-comment">-- 这个例子结合 show profiles; 查看运行时间</span><br><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><strong>需求：</strong>查询 年龄为30岁的，且员工编号小于101000的用户，按用户名称排序 </p>
<p><strong>测试1：</strong>很显然，type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> empno <span class="hljs-operator">&lt;</span><span class="hljs-number">101000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `name`;<br><span class="hljs-comment">-- 然后查看一下SQL的执行时间</span><br></code></pre></td></tr></table></figure>

<p><code>性能测试：</code><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713083659641.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713011923316.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220713083659641.png)

![](MySQL8高级-架构和优化/image-20220713011923316.png)

-->



<p><strong>优化思路：</strong> 尽量让where的过滤条件和排序使用上索引</p>
<p><strong>step1：</strong> 我们建一个三个字段的组合索引可否？ </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_age_empno_name <span class="hljs-keyword">ON</span> emp (age,empno,`name`);<br></code></pre></td></tr></table></figure>

<p>最后的name索引没有用到，出现了Using filesort。原因是，因为empno是一个范围过滤，所以索引后面的字段不会再使用索引了。所以我们建一个3值索引是没有意义的 </p>
<p><code>性能测试：</code><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713083739538.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713013325047.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220713083739538.png)

![](MySQL8高级-架构和优化/image-20220713013325047.png)

-->

<p><strong>step2：</strong>那么我们先删掉这个索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_age_empno_name <span class="hljs-keyword">ON</span> emp;<br></code></pre></td></tr></table></figure>

<p>为了去掉filesort我们可以把索引建成，也就是说empno 和name这个两个字段我只能二选其一。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_age_name <span class="hljs-keyword">ON</span> emp(age,`name`);<br></code></pre></td></tr></table></figure>

<p>这样我们优化掉了 using filesort。但是经过测试，性能反而下降</p>
<p><code>性能测试：</code><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713083832940.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713082858826.png" srcset="/img/loading.gif" lazyload>&#96;</p>
<!--

![](MySQL8高级-架构和优化/image-20220713083832940.png)

![](MySQL8高级-架构和优化/image-20220713082858826.png)

-->

<p><strong>step3：</strong>如果我们选择那个范围过滤，而放弃排序上的索引呢?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_age_name <span class="hljs-keyword">ON</span> emp;<br><span class="hljs-keyword">CREATE</span> INDEX idx_age_empno <span class="hljs-keyword">ON</span> emp(age,empno);<br></code></pre></td></tr></table></figure>

<p>执行原始的sql语句，查看性能，结果竟然有 filesort的 sql 运行速度，超过了已经优化掉 filesort的 sql，而且快了好多倍。何故？</p>
<p><code>性能测试：</code><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713083927522.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713083429530.png" srcset="/img/loading.gif" lazyload>&#96;</p>
<!--

![](MySQL8高级-架构和优化/image-20220713083927522.png)

![](MySQL8高级-架构和优化/image-20220713083429530.png)

-->

<p><strong>原因：</strong>所有的排序都是在条件过滤之后才执行的，所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。 相对的 <code>empno&lt;101000</code> 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p>
<blockquote>
<p><strong>结论：</strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</p>
<p>也可以将选择权交给MySQL：索引同时存在，mysql自动选择最优的方案：（对于这个例子，mysql选择idx_age_empno），但是，随着数据量的变化，选择的索引也会随之变化的。</p>
</blockquote>
<h3 id="7-3、双路排序和单路排序"><a href="#7-3、双路排序和单路排序" class="headerlink" title="7.3、双路排序和单路排序"></a>7.3、双路排序和单路排序</h3><p>如果排序没有使用索引，引起了filesort（手工排序），那么filesort有两种算法</p>
<ul>
<li>双路排序</li>
<li>单路排序</li>
</ul>
<p><strong>双路排序（慢）</strong></p>
<p><code>MySQL 4.1之前是使用双路排序，</code>字面意思就是<code>两次扫描磁盘</code>，最终得到数据。</p>
<ul>
<li><p>首先，根据行指针<code>从磁盘</code>取<code>排序字段</code>，在buffer进行排序。</p>
</li>
<li><p>再按照排序字段的顺序<code>从磁盘</code>取<code>其他字段</code>。</p>
</li>
</ul>
<p><code>取一批数据，要对磁盘进行两次扫描。</code>众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p>
<p><strong>单路排序（快）</strong></p>
<ul>
<li><p>从磁盘读取查询需要的<code>所有字段</code>，按照order by列在buffer对它们进行排序。</p>
</li>
<li><p>然后扫描排序后的列表进行输出。</p>
</li>
</ul>
<p>它的效率更快一些，因为<code>只读取一次磁盘</code>，避免了第二次读取数据。<code>并且把随机IO变成了顺序IO</code>。但是它会<code>使用更多的空间</code>， 因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申出的问题</strong></p>
<ul>
<li>单路比多路要多占用更多内存空间</li>
<li>因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer_size</code>的容量，导致每次只能取<code>sort_buffer_size</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I&#x2F;O。</li>
<li><code>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</code></li>
</ul>
<p><strong>优化策略</strong></p>
<ul>
<li><p><code>减少select 后面的查询的字段：</code>Order by时<code>select * 是一个大忌</code>。查询字段过多会占用sort_buffer_size的容量。</p>
</li>
<li><p><code>增大sort_buffer_size参数的设置：</code>当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL8.0，InnoDB存储引擎默认值是1048576字节，1MB。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%sort_buffer_size%&#x27;</span>; <span class="hljs-comment">--默认1MB</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/ec4536a6-8738-4aeb-9edf-0e7d42187d86.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/ec4536a6-8738-4aeb-9edf-0e7d42187d86.png)

-->

<ul>
<li><code>增大max_length_for_sort_data参数的设置：</code>MySQL根据max_length_for_sort_data变量来确定使用哪种算法，默认值是4096字节，如果需要返回的列的总长度大于max_length_for_sort_data，使用双路排序算法，否则使用单路排序算法。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I&#x2F;O活动和低的处理器使用率。1024-8192之间调整。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%max_length_for_sort_data%&#x27;</span>; <span class="hljs-comment">--默认4K</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713124733970.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220713124733970.png)

-->



<p><strong>举例：</strong></p>
<p>1、如果数据总量很小（单路一次就可以读取所有数据），单条记录大小很大（大于4K，默认会使用双路排序），此时，可以增加max_length_for_sort_data的值，增加sort_buffer_size的值，让服务器默认使用单路排序。</p>
<p>2、如果数据总量很大（单路很多次IO才可以），单条记录大小很小（小于4K，默认会使用单路排序），此时，可以减小max_length_for_sort_data的值，让服务器默认使用双路排序。</p>
<h2 id="8、分组优化"><a href="#8、分组优化" class="headerlink" title="8、分组优化"></a>8、分组优化</h2><ul>
<li><code>group by 使用索引的原则几乎跟order by一致</code>。但是group by 即使没有过滤条件用到索引，也可以直接使用索引（Order By 必须有过滤条件才能使用上索引）</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h2 id="9、覆盖索引优化"><a href="#9、覆盖索引优化" class="headerlink" title="9、覆盖索引优化"></a>9、覆盖索引优化</h2><blockquote>
<p><strong>总结</strong></p>
<ul>
<li>禁止使用select *，禁止查询与业务无关字段</li>
<li>尽量利用覆盖索引</li>
</ul>
</blockquote>
<h2 id="10、优化小口诀"><a href="#10、优化小口诀" class="headerlink" title="10、优化小口诀"></a>10、优化小口诀</h2><blockquote>
<p>全值匹配我最爱，最左前缀要遵守；<br>带头大哥不能死，中间兄弟不能断；<br>索引列上少计算，范围之后全失效；<br>like百分写最右，覆盖索引不写*；<br>不等空值还有or，索引失效要少用；<br>var引号不能丢，sql高级也不难；</p>
</blockquote>
<h1 id="第06章-慢查询日志"><a href="#第06章-慢查询日志" class="headerlink" title="第06章 慢查询日志"></a>第06章 慢查询日志</h1><h2 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h2><p>一种日志记录，查看哪些SQL超出了我们的最大忍耐时间值。</p>
<h2 id="2、开启慢查询日志参数"><a href="#2、开启慢查询日志参数" class="headerlink" title="2、开启慢查询日志参数"></a>2、开启慢查询日志参数</h2><h3 id="2-1、开启slow-query-log"><a href="#2-1、开启slow-query-log" class="headerlink" title="2.1、开启slow_query_log"></a>2.1、开启slow_query_log</h3><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure>

<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>; <br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL8%E9%AB%98%E7%BA%A7-%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BC%98%E5%8C%96/image-20220713130039824.png" srcset="/img/loading.gif" lazyload></p>
<!--

![](MySQL8高级-架构和优化/image-20220713130039824.png)

-->



<h3 id="2-2、修改long-query-time阈值"><a href="#2-2、修改long-query-time阈值" class="headerlink" title="2.2、修改long_query_time阈值"></a>2.2、修改long_query_time阈值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%long_query_time%&#x27;</span>; <span class="hljs-comment">-- 查看值：默认10秒</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time<span class="hljs-operator">=</span><span class="hljs-number">0.1</span>; <span class="hljs-comment">-- 设置一个比较短的时间，便于测试</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><strong>需要重新登录客户端</strong>使上面的设置生效</li>
<li>假如运行时间正好等于long_query_time的情况，并不会被记录下来。</li>
<li>也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。</li>
</ul>
<h3 id="2-3、日志分析工具"><a href="#2-3、日志分析工具" class="headerlink" title="2.3、日志分析工具"></a>2.3、日志分析工具</h3><p><strong>执行耗时sql：</strong></p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> deptid &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><strong>查询慢查询记录数：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Slow_queries%&#x27;</span>; <br></code></pre></td></tr></table></figure>

<p><strong>查询日志：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">注意这个地方是容器中的<br>vim /var/lib/mysql/atguigu-slow.log<br></code></pre></td></tr></table></figure>

<p><strong>mysqldumpslow：</strong></p>
<p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。退出mysql命令行，执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看mysqldumpslow的帮助信息</span><br>mysqldumpslow <span class="hljs-comment">--help</span><br><br><span class="hljs-comment">-- 工作常用参考</span><br><span class="hljs-comment">-- 1.得到返回记录集最多的10个SQL</span><br>mysqldumpslow <span class="hljs-operator">-</span>s r <span class="hljs-operator">-</span>t <span class="hljs-number">10</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>slow.log<br><span class="hljs-comment">-- 2.得到访问次数最多的10个SQL</span><br>mysqldumpslow <span class="hljs-operator">-</span>s c <span class="hljs-operator">-</span>t <span class="hljs-number">10</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>slow.log<br><span class="hljs-comment">-- 3.得到按照时间排序的前10条里面含有左连接的查询语句</span><br>mysqldumpslow <span class="hljs-operator">-</span>s t <span class="hljs-operator">-</span>t <span class="hljs-number">10</span> <span class="hljs-operator">-</span>g &quot;left join&quot; <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>slow.log<br><span class="hljs-comment">-- 4.另外建议在使用这些命令时结合 | 和more 使用 ，否则语句过多有可能出现爆屏情况</span><br>mysqldumpslow <span class="hljs-operator">-</span>s r <span class="hljs-operator">-</span>t <span class="hljs-number">10</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>atguigu<span class="hljs-operator">-</span>slow.log <span class="hljs-operator">|</span> more<br></code></pre></td></tr></table></figure>

<ul>
<li><p>-a: 不将数字抽象成N，字符串抽象成S</p>
</li>
<li><p>-s: 是表示按照何种方式排序；</p>
<ul>
<li><p>c: sql语句的访问次数</p>
</li>
<li><p>l: 锁定时间</p>
</li>
<li><p>r: 返回数据记录集的总数量</p>
</li>
<li><p>t: 查询时间</p>
</li>
<li><p>al:平均锁定时间</p>
</li>
<li><p>ar:平均返回记录数</p>
</li>
<li><p>at:平均查询时间</p>
</li>
</ul>
</li>
<li><p>-t: 即为返回前面多少条的数据；</p>
</li>
<li><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p>
</li>
</ul>
<h1 id="第07章-View视图"><a href="#第07章-View视图" class="headerlink" title="第07章 View视图"></a>第07章 View视图</h1><h2 id="1、是什么-1"><a href="#1、是什么-1" class="headerlink" title="1、是什么"></a>1、是什么</h2><ul>
<li>将一段查询sql封装为一个虚拟的表。 </li>
<li>这个虚拟表只保存了sql逻辑，不会保存任何查询结果。</li>
</ul>
<h2 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h2><ul>
<li>封装复杂sql语句，提高复用性</li>
<li>逻辑放在数据库上面，更新不需要发布程序，面对频繁的需求变更更灵活</li>
</ul>
<h2 id="3、适用场景"><a href="#3、适用场景" class="headerlink" title="3、适用场景"></a>3、适用场景</h2><ul>
<li>共用查询结果</li>
<li>报表</li>
</ul>
<h2 id="4、语法"><a href="#4、语法" class="headerlink" title="4、语法"></a>4、语法</h2><h3 id="4-1、创建"><a href="#4-1、创建" class="headerlink" title="4.1、创建"></a>4.1、创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> view_name <br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br><br><span class="hljs-comment">-- 例如：求所有人物对应的掌门名称</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v_ceo <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> emp.name, ceo.name <span class="hljs-keyword">AS</span> ceoname <br><span class="hljs-keyword">FROM</span> t_emp emp<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept dept <span class="hljs-keyword">ON</span> emp.deptid <span class="hljs-operator">=</span> dept.id <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_emp ceo <span class="hljs-keyword">ON</span> dept.ceo <span class="hljs-operator">=</span> ceo.id;<br></code></pre></td></tr></table></figure>



<h3 id="4-2、使用"><a href="#4-2、使用" class="headerlink" title="4.2、使用"></a>4.2、使用</h3><p><strong>查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> view_name; <br><br><span class="hljs-comment">-- 例如：</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> v_ceo; <br></code></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> view_name <br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> column_name(s) <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span><br><br><span class="hljs-comment">-- 建议直接删除重新创建</span><br></code></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> view_name;<br><br><span class="hljs-comment">-- 例如：</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> v_ceo;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" class="category-chain-item">技术栈</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/" class="category-chain-item">MySQL</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL高级一</div>
      <div>http://example.com/2023/04/28/技术栈/MySQL/MySQL8高级-架构和优化/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>pz</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/28/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/MySQL%E8%AF%BE%E4%BB%B6%E8%A1%A5%E5%85%85/" title="MySQL高级二">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL高级二</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/21/%E6%8A%80%E6%9C%AF%E6%A0%88/MySQL/mysql%E8%AF%AD%E5%8F%A5/" title="MySQL语句">
                        <span class="hidden-mobile">MySQL语句</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
