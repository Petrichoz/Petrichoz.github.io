<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ工作模式"><a href="#RabbitMQ工作模式" class="headerlink" title="RabbitMQ工作模式"></a>RabbitMQ工作模式</h1><ul><li>RabbitMQ提供了<strong>多种工作模式</strong>：简单模式，work模式 ，Publish&#x2F;Subscribe发布与订阅模式，Routing路由模式，Topics主题模式等</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806102313708.png" alt="image-20240806102313708"></p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a> </p><h1 id="1-Work-queues工作队列模式"><a href="#1-Work-queues工作队列模式" class="headerlink" title="1 Work queues工作队列模式"></a><strong>1 Work queues工作队列模式</strong></h1><h2 id="1-1-模式说明"><a href="#1-1-模式说明" class="headerlink" title="1.1 模式说明"></a><strong>1.1 模式说明</strong></h2><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806084946234.png" alt="image-20240806084946234"> </p><p>Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。</p><p><strong>应用场景</strong>：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p><h2 id="1-2-工作队列模式代码"><a href="#1-2-工作队列模式代码" class="headerlink" title="1.2 工作队列模式代码"></a>1.2 工作队列模式代码</h2><h3 id="1-2-1-生产者代码"><a href="#1-2-1-生产者代码" class="headerlink" title="1.2.1 生产者代码"></a>1.2.1 生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_WORK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.queue.work&quot;</span>;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageWork</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        rabbitTemplate.convertAndSend(<br>                EXCHANGE_DIRECT,<br>                ROUTING_KEY_WORK,<br>                <span class="hljs-string">&quot;Hello atguigu &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>发送消息效果</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725203346015.png" alt="image-20240725203346015"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725203322613.png" alt="image-20240725203322613"></p><h3 id="1-2-2-消费者代码"><a href="#1-2-2-消费者代码" class="headerlink" title="1.2.2 消费者代码"></a>1.2.2 消费者代码</h3><h4 id="①创建模块，配置POM"><a href="#①创建模块，配置POM" class="headerlink" title="①创建模块，配置POM"></a>①创建模块，配置POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="②YAML"><a href="#②YAML" class="headerlink" title="②YAML"></a>②YAML</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.47</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h4 id="③主启动类"><a href="#③主启动类" class="headerlink" title="③主启动类"></a>③主启动类</h4><p>仿照生产者工程的主启动类，改一下类名即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConsumerMainType</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitMQConsumerMainType.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④监听器"><a href="#④监听器" class="headerlink" title="④监听器"></a>④监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serverPort;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.work&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Server Port:&quot;</span> + serverPort + <span class="hljs-string">&quot; Message Content:&quot;</span> + messageContent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-3-运行效果"><a href="#1-2-3-运行效果" class="headerlink" title="1.2.3 运行效果"></a>1.2.3 运行效果</h3><h4 id="①消费端A"><a href="#①消费端A" class="headerlink" title="①消费端A"></a>①消费端A</h4><blockquote><p>Server Port:10000 Message Content:Hello atguigu 0<br>Server Port:10000 Message Content:Hello atguigu 2<br>Server Port:10000 Message Content:Hello atguigu 4<br>Server Port:10000 Message Content:Hello atguigu 6<br>Server Port:10000 Message Content:Hello atguigu 8</p></blockquote><h4 id="②消费端B"><a href="#②消费端B" class="headerlink" title="②消费端B"></a>②消费端B</h4><blockquote><p>Server Port:20000 Message Content:Hello atguigu 1<br>Server Port:20000 Message Content:Hello atguigu 3<br>Server Port:20000 Message Content:Hello atguigu 5<br>Server Port:20000 Message Content:Hello atguigu 7<br>Server Port:20000 Message Content:Hello atguigu 9</p></blockquote><h1 id="2-订阅模式类型"><a href="#2-订阅模式类型" class="headerlink" title="2 订阅模式类型"></a><strong>2 订阅模式类型</strong></h1><p>订阅模式示例图：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085107277.png" alt="image-20240806085107277"> </p><p>前面2个案例中，只有3个角色：</p><p>· P：生产者，也就是要发送消息的程序</p><p>· C：消费者：消息的接受者，会一直等待消息到来。</p><p>· queue：消息队列，图中红色部分</p><p>而在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><p>· P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p><p>· C：消费者，消息的接受者，会一直等待消息到来。</p><p>· Queue：消息队列，接收消息、缓存消息。</p><p>· Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p><p><strong>Exchange有常见以下3种类型</strong>：</p><p>o Fanout：广播，将消息交给所有绑定到交换机的队列</p><p>o Direct：定向，把消息交给符合指定routing key 的队列</p><p>o Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h1 id="3-Publish-Subscribe发布订阅模式"><a href="#3-Publish-Subscribe发布订阅模式" class="headerlink" title="3 Publish&#x2F;Subscribe发布订阅模式"></a>3 Publish&#x2F;Subscribe发布订阅模式</h1><p>一句话总结</p><p>在队列接收消息中间加了一个交换机，交换机可以设定路由规则将消息分发到对应的队列里面，然后消费者设定规则去对应队列里面获取消息数据</p><h2 id="3-1-模式说明"><a href="#3-1-模式说明" class="headerlink" title="3.1 模式说明"></a>3.1 模式说明</h2><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085123819.png" alt="image-20240806085123819"> </p><p>发布订阅模式：<br>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息</p><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><h3 id="1-创建组件"><a href="#1-创建组件" class="headerlink" title="1 创建组件"></a>1 创建组件</h3><ul><li>名称列表</li></ul><table><thead><tr><th>组件</th><th>组件名称</th></tr></thead><tbody><tr><td>交换机</td><td>atguigu.exchange.fanout</td></tr><tr><td>队列</td><td>atguigu.queue.fanout01<br>atguigu.queue.fanout02</td></tr></tbody></table><h3 id="2-创建交换机"><a href="#2-创建交换机" class="headerlink" title="2 创建交换机"></a>2 创建交换机</h3><p><span style="color:blue;"><strong>注意</strong></span>：发布订阅模式要求交换机是Fanout类型</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725210428356.png" alt="image-20240725210428356"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725210526288.png" alt="image-20240725210526288"></p><h3 id="3-创建队列并绑定交换机"><a href="#3-创建队列并绑定交换机" class="headerlink" title="3 创建队列并绑定交换机"></a>3 创建队列并绑定交换机</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725210906899.png" alt="image-20240725210906899"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725211118200.png" alt="image-20240725211118200"></p><p>此时可以到交换机下查看绑定关系：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725211206904.png" alt="image-20240725211206904"></p><h3 id="4-生产者代码"><a href="#4-生产者代码" class="headerlink" title="4 生产者代码"></a>4 生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_FANOUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.exchange.fanout&quot;</span>;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageFanout</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(EXCHANGE_FANOUT, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Hello fanout ~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-消费者代码"><a href="#5-消费者代码" class="headerlink" title="5 消费者代码"></a>5 消费者代码</h3><p>两个监听器可以写在同一个微服务中，分别监听两个不同队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.fanout01&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage01</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Consumer01 Message Content:&quot;</span> + messageContent);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.fanout02&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage02</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Consumer02 Message Content:&quot;</span> + messageContent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-运行效果"><a href="#6-运行效果" class="headerlink" title="6 运行效果"></a>6 运行效果</h3><p>先启动消费者，然后再运行生产者程序发送消息：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725212632041.png" alt="image-20240725212632041"></p><h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p><p><strong>发布订阅模式与工作队列模式的区别：</strong></p><ul><li>工作队列模式本质上是绑定默认交换机</li><li>发布订阅模式绑定指定交换机</li><li>监听同一个队列的消费端程序彼此之间是竞争关系</li><li>绑定同一个交换机的多个队列在发布订阅模式下，消息是广播的，每个队列都能接收到消息</li></ul><h1 id="4-Routing路由模式"><a href="#4-Routing路由模式" class="headerlink" title="4 Routing路由模式"></a>4 Routing路由模式</h1><h2 id="4-1-模式说明"><a href="#4-1-模式说明" class="headerlink" title="4.1 模式说明"></a>4.1 模式说明</h2><p>路由模式特点：</p><p>· 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p><p>· 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。</p><p>· Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085148987.png" alt="image-20240806085148987"> </p><p>图解：</p><p>· P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p><p>· X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p><p>· C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p><p>· C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p><h2 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h2><h3 id="1-创建组件-1"><a href="#1-创建组件-1" class="headerlink" title="1 创建组件"></a>1 创建组件</h3><ul><li>组件清单</li></ul><p>没有特殊设置，名称外的其它参数都使用默认值：</p><table><thead><tr><th>组件</th><th>组件名称</th></tr></thead><tbody><tr><td>交换机</td><td>atguigu.exchange.direct</td></tr><tr><td>路由键</td><td>atguigu.routing.key.good</td></tr><tr><td>队列</td><td>atguigu.queue.direct</td></tr></tbody></table><h3 id="2-绑定"><a href="#2-绑定" class="headerlink" title="2 绑定"></a>2 绑定</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725214547261.png" alt="image-20240725214547261"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725214608820.png" alt="image-20240725214608820"></p><h3 id="3-生产者代码"><a href="#3-生产者代码" class="headerlink" title="3 生产者代码"></a>3 生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.exchange.direct&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_GOOD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.routing.key.good&quot;</span>;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageRouting</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(EXCHANGE_DIRECT, ROUTING_KEY_GOOD, <span class="hljs-string">&quot;Hello routing ~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-消费者代码"><a href="#4-消费者代码" class="headerlink" title="4 消费者代码"></a>4 消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.direct&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessageRouting</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Message Content:&quot;</span> + messageContent);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5 运行结果"></a>5 运行结果</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725215245500.png" alt="image-20240725215245500"></p><h1 id="5-Topics通配符模式"><a href="#5-Topics通配符模式" class="headerlink" title="5 Topics通配符模式"></a>5 Topics通配符模式</h1><h2 id="5-1-模式说明"><a href="#5-1-模式说明" class="headerlink" title="5.1. 模式说明"></a><strong>5.1. 模式说明</strong></h2><p>Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候<strong>使用通配符</strong>！</p><p>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p><p>通配符规则：</p><p>#：匹配零个或多个词</p><p>*：匹配不多不少恰好1个词</p><p>举例：</p><p>item.#：能够匹配item.insert.abc 或者 item.insert</p><p>item.*：只能匹配item.insert</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085214905.png" alt="image-20240806085214905"> </p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/wps14.jpg" alt="img"> </p><p>图解：</p><p>· 红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到</p><p>· 黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配</p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><h3 id="1-创建组件-2"><a href="#1-创建组件-2" class="headerlink" title="1 创建组件"></a>1 创建组件</h3><ul><li>组件清单</li></ul><table><thead><tr><th>组件</th><th>组件名称</th></tr></thead><tbody><tr><td>交换机</td><td>atguigu.exchange.topic</td></tr><tr><td>路由键</td><td>#.error<br>order.*<br>*.*</td></tr><tr><td>队列</td><td>atguigu.queue.message<br>atguigu.queue.order</td></tr></tbody></table><h3 id="2-创建交换机-1"><a href="#2-创建交换机-1" class="headerlink" title="2 创建交换机"></a>2 创建交换机</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725220957833.png" alt="image-20240725220957833"></p><h3 id="3-绑定关系"><a href="#3-绑定关系" class="headerlink" title="3 绑定关系"></a>3 绑定关系</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725222339828.png" alt="image-20240725222339828"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725222805072.png" alt="image-20240725222805072"></p><h3 id="4-生产者代码-1"><a href="#4-生产者代码-1" class="headerlink" title="4 生产者代码"></a>4 生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.exchange.topic&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#.error&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_ORDER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order.*&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_ALL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;*.*&quot;</span>;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageTopic</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(EXCHANGE_TOPIC, <span class="hljs-string">&quot;order.info&quot;</span>, <span class="hljs-string">&quot;message order info ...&quot;</span>);<br>    rabbitTemplate.convertAndSend(EXCHANGE_TOPIC, <span class="hljs-string">&quot;goods.info&quot;</span>, <span class="hljs-string">&quot;message goods info ...&quot;</span>);<br>    rabbitTemplate.convertAndSend(EXCHANGE_TOPIC, <span class="hljs-string">&quot;goods.error&quot;</span>, <span class="hljs-string">&quot;message goods error ...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-消费者代码-1"><a href="#5-消费者代码-1" class="headerlink" title="5 消费者代码"></a>5 消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.message&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage01</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Queue Message:&quot;</span> + messageContent);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.order&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage02</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Queue Order:&quot;</span> + messageContent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-运行效果-1"><a href="#6-运行效果-1" class="headerlink" title="6 运行效果"></a>6 运行效果</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240725223737173.png" alt="image-20240725223737173"></p><h1 id="6-模式总结"><a href="#6-模式总结" class="headerlink" title="6 模式总结"></a>6 模式总结</h1><h2 id="1、简单模式-HelloWorld"><a href="#1、简单模式-HelloWorld" class="headerlink" title="1、简单模式 HelloWorld"></a><strong>1、简单模式 HelloWorld</strong></h2><p>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085244893.png" alt="image-20240806085244893"> </p><h2 id="2、工作队列模式-Work-Queue"><a href="#2、工作队列模式-Work-Queue" class="headerlink" title="2、工作队列模式 Work Queue"></a><strong>2、工作队列模式 Work Queue</strong></h2><p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085305207.png" alt="image-20240806085305207"> </p><h2 id="3、发布订阅模式-Publish-subscribe"><a href="#3、发布订阅模式-Publish-subscribe" class="headerlink" title="3、发布订阅模式 Publish&#x2F;subscribe"></a><strong>3、发布订阅模式 Publish&#x2F;subscribe</strong></h2><p>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085325073.png" alt="image-20240806085325073"> </p><h2 id="4、路由模式-Routing"><a href="#4、路由模式-Routing" class="headerlink" title="4、路由模式 Routing"></a><strong>4、路由模式 Routing</strong></h2><p>需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><p> <img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085354471.png" alt="image-20240806085354471"></p><h2 id="5、通配符模式-Topic"><a href="#5、通配符模式-Topic" class="headerlink" title="5、通配符模式 Topic"></a><strong>5、通配符模式 Topic</strong></h2><p>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><p> <img src="/2024/11/04/RabbitMQ/%E7%AC%AC3%E7%AB%A0%20RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240806085413115.png" alt="image-20240806085413115"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ入门案例"><a href="#RabbitMQ入门案例" class="headerlink" title="RabbitMQ入门案例"></a>RabbitMQ入门案例</h1><h1 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h1><p>生产者发送消息，消费者接收消息，用最简单的方式实现</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/image-20240806084908636.png" alt="image-20240806084908636"></p><h1 id="二、创建队列"><a href="#二、创建队列" class="headerlink" title="二、创建队列"></a>二、创建队列</h1><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/image-20240725175936170.png" alt="image-20240725175936170"></p><p>队列名称：atguigu.queue.simple</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/image-20240725180208216.png" alt="image-20240725180208216"></p><h1 id="三、Java-客户端：整合-SpringBoot"><a href="#三、Java-客户端：整合-SpringBoot" class="headerlink" title="三、Java 客户端：整合 SpringBoot"></a>三、Java 客户端：整合 SpringBoot</h1><h2 id="1、生产者端工程"><a href="#1、生产者端工程" class="headerlink" title="1、生产者端工程"></a>1、生产者端工程</h2><h3 id="①创建module"><a href="#①创建module" class="headerlink" title="①创建module"></a>①创建module</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/img75.png" alt="images"></p><h3 id="②配置POM"><a href="#②配置POM" class="headerlink" title="②配置POM"></a>②配置POM</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="③YAML"><a href="#③YAML" class="headerlink" title="③YAML"></a>③YAML</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">rabbitmq:</span> <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.47</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span> <br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span> <br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><h3 id="④主启动类"><a href="#④主启动类" class="headerlink" title="④主启动类"></a>④主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq;  <br>  <br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;  <br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;  <br>  <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProducerMainType</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitMQProducerMainType.class, args);  <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⑤测试程序"><a href="#⑤测试程序" class="headerlink" title="⑤测试程序"></a>⑤测试程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.test;<br>  <br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQTest</span> &#123;  <br>  <br>    <span class="hljs-comment">// 在简单模式下，没有用到交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>    <span class="hljs-comment">// 在简单模式下，消息直接发送到队列，此时生产者端需要把队列名称从路由键参数这里传入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_SIMPLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.queue.simple&quot;</span>;<br>  <br>    <span class="hljs-comment">// 注入 RabbitTemplate 执行</span><br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageSimple</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(  <br>                EXCHANGE_DIRECT,   <span class="hljs-comment">// 指定交换机名称</span><br>                ROUTING_KEY_SIMPLE, <span class="hljs-comment">// 指定路由键名称</span><br>                <span class="hljs-string">&quot;Hello atguigu&quot;</span>);   <span class="hljs-comment">// 消息内容，也就是消息数据本身</span><br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⑥测试效果"><a href="#⑥测试效果" class="headerlink" title="⑥测试效果"></a>⑥测试效果</h3><p>消息发送到了队列中：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/image-20240725193430307.png" alt="image-20240725193430307"></p><h2 id="2、消费端工程"><a href="#2、消费端工程" class="headerlink" title="2、消费端工程"></a>2、消费端工程</h2><h3 id="①创建module-1"><a href="#①创建module-1" class="headerlink" title="①创建module"></a>①创建module</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/img76-17306871500848.png" alt="images"></p><h3 id="②配置POM-1"><a href="#②配置POM-1" class="headerlink" title="②配置POM"></a>②配置POM</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="③YAML-1"><a href="#③YAML-1" class="headerlink" title="③YAML"></a>③YAML</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.47</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><h3 id="④主启动类-1"><a href="#④主启动类-1" class="headerlink" title="④主启动类"></a>④主启动类</h3><p>仿照生产者工程的主启动类，改一下类名即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConsumerMainType</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitMQConsumerMainType.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⑤监听器"><a href="#⑤监听器" class="headerlink" title="⑤监听器"></a>⑤监听器</h3><ul><li>使用 @RabbitListener 注解设定要监听的队列名称</li><li>消息数据使用和发送端一样的数据类型接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;atguigu.queue.simple&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String messageContent, Message message, Channel channel)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;messageContent = &quot;</span> + messageContent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⑥执行测试"><a href="#⑥执行测试" class="headerlink" title="⑥执行测试"></a>⑥执行测试</h3><p>监听方法不能直接运行，请大家通过主启动类运行微服务。消费端取走消息之后，队列中就没有消息了：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC2%E7%AB%A0%20RabbitMQ%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/image-20240725194639024.png" alt="image-20240725194639024"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ概述和安装"><a href="#RabbitMQ概述和安装" class="headerlink" title="RabbitMQ概述和安装"></a>RabbitMQ概述和安装</h1><h1 id="一、消息中间件概述"><a href="#一、消息中间件概述" class="headerlink" title="一、消息中间件概述"></a>一、消息中间件概述</h1><h2 id="1-为什么学习消息队列"><a href="#1-为什么学习消息队列" class="headerlink" title="1 为什么学习消息队列"></a>1 为什么学习消息队列</h2><p>在互联网应用中，经常需要对庞大的海量数据进行监控，随着网络技术和软件开发技术的不断提高，在实战开发中MQ的使用与日俱增，特别是RabbitMQ在分布式系统中存储转发消息，可以保证数据不丢失，也能保证高可用性，即集群部署的时候部分机器宕机可以继续运行。在大型电子商务类网站，如京东、淘宝、去哪儿等网站有着深入的应用 。</p><p>消息队列的主要作用是<strong>消除高并发访问高峰，加快网站的响应速度</strong>。</p><p>在不使用消息队列的情况下，用户的请求数据直接写入数据库，在高并发的情况下，会对数据库造成巨大的压力，同时也使得系统响应延迟加剧。</p><h2 id="2-什么是消息中间件"><a href="#2-什么是消息中间件" class="headerlink" title="2 什么是消息中间件"></a>2 什么是消息中间件</h2><p>MQ全称为<strong>Message Queue</strong>， 消息队列(MQ)是一种应用程序对应用程序的通信方法。</p><p>介绍：消息队列就是基础数据结构中的“先进先出”的一种数据机构。想一下，生活中买东西，需要排队，先排的人先买消费，就是典型的“先进先出”。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240806135209860.png" alt="image-20240806135209860"></p><p><strong>消息传递：</strong>指的是程序之间通过消息发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。</p><p><strong>排队：</strong>指的是应用程序通过队列来通信。</p><p><strong>业务场景说明：</strong></p><p>消息队列在大型电子商务类网站，如京东、淘宝、去哪儿等网站有着深入的应用，为什么会产生消息队列？有几个原因：</p><p>不同进程（process）之间传递消息时，两个进程之间<strong>耦合</strong>程度过高，改动一个进程，引发必须修改另一个进程，为了<strong>隔离</strong>这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；</p><p>不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的<strong>消息太多</strong>，一下子无法处理完，并且也有先后顺序，必须对收到的消息<strong>进行排队</strong>，因此诞生了事实上的消息队列；</p><p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>。</p><h2 id="3-消息队列应用场景"><a href="#3-消息队列应用场景" class="headerlink" title="3 消息队列应用场景"></a>3 消息队列应用场景</h2><p>首先我们先说一下消息中间件的主要的作用：</p><p>　　<strong>[1]异步处理</strong></p><p>　　<strong>[2]解耦服务</strong></p><p>　　<strong>[3]流量削峰</strong></p><p>​        <font style="color:red">分布式事务</font></p><p>上面的三点是我们使用消息中间件最主要的目的.</p><h3 id="3-1-应用解耦"><a href="#3-1-应用解耦" class="headerlink" title="3.1 应用解耦"></a>3.1 应用解耦</h3><ul><li>以下单功能为例，如下图，存在功能耦合度高的问题。</li><li>用户下单，需要保存订单，更新购物车，更新库存，还要更新积分，如果在操作过程中，有任何一个环节失败了，最终会导致操作失败，返回错误信息</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240805155818298.png" alt="image-20240805155818298"></p><ul><li>而采用消息队列方式，可以很好的解决耦合度过高问题</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240805160108001.png" alt="image-20240805160108001"></p><h3 id="3-2-异步处理"><a href="#3-2-异步处理" class="headerlink" title="3.2 异步处理"></a>3.2 异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信，传统的做法有两种</p><ul><li><p>串行的方式</p></li><li><p>并行的方式</p></li></ul><p><strong>(1)</strong> <strong>串行方式：</strong></p><p>将注册信息写入数据库后，发送注册邮件，再发送注册短信，以上三个任务全部完成后才返回给客户端。 这有一个问题是，邮件，短信并不是必须的，它只是一个通知，而这种做法让客户端等待没有必要等待的东西。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/wps1.jpg" alt="img"> </p><p><strong>(2)</strong> <strong>并行方式：</strong></p><p>将注册信息写入数据库后，发送邮件的同时，发送短信，以上三个任务完成后，返回给客户端，并行的方式能提高处理的时间。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/wps2.jpg" alt="img"> </p><p>假设三个业务节点分别使用50ms，串行方式使用时间150ms，并行使用时间100ms。虽然并行已经提高了处理时间，但是，前面说过，邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功，应该是写入数据库后就返回.</p><p><strong>(3)消息队列</strong><br>引入消息队列后，把发送邮件，短信不是必须的业务逻辑异步处理</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/wps3.jpg" alt="img"> </p><p>由此可以看出，引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计)，</p><p>引入消息队列后处理后，响应时间是串行的3分之1，是并行的2分之1。</p><p><strong>传统模式的缺点：</strong></p><p>· 一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p><p><strong>中间件模式的的优点：</strong></p><p>· 将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p><h3 id="3-3-流量削峰"><a href="#3-3-流量削峰" class="headerlink" title="3.3 流量削峰"></a>3.3 流量削峰</h3><p>流量削峰一般在秒杀活动中应用广泛</p><p><strong>场景：</strong> 秒杀活动，一般会因为流量过大，导致应用挂掉，为了解决这个问题，一般在应用前端加入消息队列。</p><p><strong>传统模式</strong></p><p>如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/wps4.jpg" alt="img"> </p><p><strong>传统模式的缺点：</strong></p><p>· 并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p><p><strong>中间件模式：</strong></p><p>消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/wps5.jpg" alt="img"> </p><p><strong>中间件模式的的优点：</strong></p><p>系统A慢慢按照数据库能处理的并发量，从消息队列中拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p><p><strong>流量削峰也叫做削峰填谷</strong></p><p>使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在 3消费完积压的消息，这就叫做“填谷”</p><h2 id="4-AMQP-和-JMS"><a href="#4-AMQP-和-JMS" class="headerlink" title="4 AMQP 和 JMS"></a><strong>4 AMQP 和 JMS</strong></h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p><h3 id="4-1-AMQP"><a href="#4-1-AMQP" class="headerlink" title="4.1. AMQP"></a><strong>4.1. AMQP</strong></h3><p>AMQP是一种<strong>高级消息队列协议（Advanced Message Queuing Protocol），更准确的说是一种binary wire-level protocol（</strong>链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p><h3 id="4-2-JMS"><a href="#4-2-JMS" class="headerlink" title="4.2. JMS"></a><strong>4.2. JMS</strong></h3><p>JMS即<strong>Java消息服务（JavaMessage Service）</strong>应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><h3 id="4-3-AMQP-与-JMS-区别"><a href="#4-3-AMQP-与-JMS-区别" class="headerlink" title="4.3. AMQP 与 JMS 区别"></a><strong>4.3. AMQP 与 JMS 区别</strong></h3><p>· JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</p><p>· JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</p><p>· JMS规定了两种消息模式；而AMQP的消息模式更加丰富</p><h2 id="5-消息队列产品"><a href="#5-消息队列产品" class="headerlink" title="5 消息队列产品"></a><strong>5 消息队列产品</strong></h2><p>市场上常见的消息队列有如下：</p><p>· ActiveMQ：基于JMS</p><p>· ZeroMQ：基于C语言开发</p><p>· Rabbitmq:基于AMQP协议，erlang语言开发，稳定性好</p><p>· RocketMQ：基于JMS，阿里巴巴产品</p><p>· Kafka：类似MQ的产品；分布式消息系统，高吞吐量</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240805160953981.png" alt="image-20240805160953981"></p><h2 id="6-RabbitMQ介绍"><a href="#6-RabbitMQ介绍" class="headerlink" title="6 RabbitMQ介绍"></a>6 RabbitMQ介绍</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><p>AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。 </p><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a> </p><p>RabbitMQ提供了<strong>多种工作模式</strong>：简单模式，work模式 ，Publish&#x2F;Subscribe发布与订阅模式，Routing路由模式，Topics主题模式等</p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a> </p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240806084552095.png" alt="image-20240806084552095"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240806084732986.png" alt="image-20240806084732986"></p><h3 id="6-2-RabbitMQ基础架构"><a href="#6-2-RabbitMQ基础架构" class="headerlink" title="6.2 RabbitMQ基础架构"></a>6.2 RabbitMQ基础架构</h3><ul><li><strong>基础架构图</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240806102134889.png" alt="image-20240806102134889"> </p><ul><li><strong>RabbitMQ相关概念</strong></li></ul><p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p><p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p><p><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：**direct (point-to-point)**， <strong>topic (publish-subscribe)</strong> and <strong>fanout (multicast)</strong></p><p><strong>Queue：</strong>存储消息的容器，消息最终被送到这里，等待 consumer 取走</p><p><strong>Binding：</strong>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p><h1 id="二、RabbitMQ安装"><a href="#二、RabbitMQ安装" class="headerlink" title="二、RabbitMQ安装"></a>二、RabbitMQ安装</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取镜像</span><br>docker pull rabbitmq:3.13-management<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 参数：后台运行 Docker 容器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--name 参数：设置容器名称</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 参数：映射端口号，格式是“宿主机端口号:容器内端口号”。5672供客户端程序访问，15672供后台管理界面访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v 参数：卷映射目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-e 参数：设置容器内的环境变量，这里我们设置了登录RabbitMQ管理后台的默认用户和密码</span><br>docker run -d \<br>--name rabbitmq \<br>-p 5672:5672 \<br>-p 15672:15672 \<br>-v rabbitmq-plugin:/plugins \<br>-e RABBITMQ_DEFAULT_USER=guest \<br>-e RABBITMQ_DEFAULT_PASS=123456 \<br>rabbitmq:3.13-management<br></code></pre></td></tr></table></figure><h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2 验证"></a>2 验证</h2><p>访问后台管理界面：<a href="http://192.168.200.100:15672/">http://192.168.200.100:15672</a></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20231102194452610.png" alt="image-20231102194452610"></p><p>使用上面创建Docker容器时指定的默认用户名、密码登录：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20231102194633997.png" alt="image-20231102194633997"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20231102194746743.png" alt="image-20231102194746743"></p><h2 id="3-可能的问题1：Docker升级"><a href="#3-可能的问题1：Docker升级" class="headerlink" title="3 可能的问题1：Docker升级"></a>3 可能的问题1：Docker升级</h2><h3 id="3-1-问题现象"><a href="#3-1-问题现象" class="headerlink" title="3.1 问题现象"></a>3.1 问题现象</h3><p>在使用Docker拉取RabbitMQ镜像的时候，如果遇到提示：missing signature key，那就说明Docker版本太低了，需要升级</p><p>比如我目前的Docker版本如下图所示：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20231105151245299.png" alt="image-20231105151245299"></p><h3 id="3-2-解决办法"><a href="#3-2-解决办法" class="headerlink" title="3.2 解决办法"></a>3.2 解决办法</h3><blockquote><p>基于CentOS7</p></blockquote><h4 id="①卸载当前Docker"><a href="#①卸载当前Docker" class="headerlink" title="①卸载当前Docker"></a>①卸载当前Docker</h4><p>更好的办法是安装Docker前曾经给服务器拍摄了快照，此时恢复快照；</p><p>如果不曾拍摄快照，那只能执行卸载操作了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum erase -y docker \<br>docker-client \<br>docker-client-latest \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-selinux \<br>docker-engine-selinux \<br>docker-engine \<br>docker-ce<br></code></pre></td></tr></table></figure><h4 id="②升级yum库"><a href="#②升级yum库" class="headerlink" title="②升级yum库"></a>②升级yum库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update -y<br></code></pre></td></tr></table></figure><h4 id="③安装Docker最新版"><a href="#③安装Docker最新版" class="headerlink" title="③安装Docker最新版"></a>③安装Docker最新版</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><p>如果这一步看到提示：没有可用软件包 docker-ce，那就添加Docker的yum源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils<br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="④设置Docker服务"><a href="#④设置Docker服务" class="headerlink" title="④设置Docker服务"></a>④设置Docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br>systemctl enable docker<br></code></pre></td></tr></table></figure><h3 id="3-3-验证"><a href="#3-3-验证" class="headerlink" title="3.3 验证"></a>3.3 验证</h3><p>上述操作执行完成后，再次查看Docker版本：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240321113218105.png" alt="image-20240321113218105"></p><h2 id="4-可能的问题：拉取镜像失败"><a href="#4-可能的问题：拉取镜像失败" class="headerlink" title="4 可能的问题：拉取镜像失败"></a>4 可能的问题：拉取镜像失败</h2><h3 id="1、问题现象"><a href="#1、问题现象" class="headerlink" title="1、问题现象"></a>1、问题现象</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC1%E7%AB%A0%20RabbitMQ%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/image-20240724113003339.png" alt="image-20240724113003339"></p><h3 id="2、解决办法"><a href="#2、解决办法" class="headerlink" title="2、解决办法"></a>2、解决办法</h3><h4 id="①daemon-json"><a href="#①daemon-json" class="headerlink" title="①daemon.json"></a>①daemon.json</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建或修改 docker 守护进程配置文件：daemon.json</span><br>vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><h4 id="②修改镜像源"><a href="#②修改镜像源" class="headerlink" title="②修改镜像源"></a>②修改镜像源</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span>: <span class="hljs-string">[&quot;https://registry.dockermirror.com&quot;]</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="③重启docker服务"><a href="#③重启docker服务" class="headerlink" title="③重启docker服务"></a>③重启docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><h4 id="④查看修改后的镜像源"><a href="#④查看修改后的镜像源" class="headerlink" title="④查看修改后的镜像源"></a>④查看修改后的镜像源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker info<br></code></pre></td></tr></table></figure><p>部分内容举例如下：</p><blockquote><p>…… </p><p>Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker<br> Debug Mode: false<br> Experimental: false<br> Insecure Registries:<br>  127.0.0.0&#x2F;8<br> Registry Mirrors:<br>  <a href="https://registry.dockermirror.com/">https://registry.dockermirror.com/</a><br> Live Restore Enabled: fals</p></blockquote><p>最后再尝试重新拉取所需镜像</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li><p>延迟队列存储的对象肯定是对应的延时消息，所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。</p></li><li><p>场景：在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行取消处理。这时就可以使用延时队列将订单信息发送到延时队列。</p></li><li><p>需求：</p></li></ul><ol><li><p>下单后，30分钟未支付，取消订单，回滚库存。</p></li><li><p>新用户注册成功30分钟后，发送短信问候。</p></li></ol><ul><li>实现：</li></ul><p>使用延迟队列实现</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240806095835083.png" alt="image-20240806095835083"></p><p>很可惜，在RabbitMQ中并未提供延迟队列功能</p><p>我们可以采用以下方案实现：</p><p>方案1：借助消息超时时间+死信队列</p><p>方案2：给RabbitMQ安装插件</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240806100015448.png" alt="image-20240806100015448"></p><p>注：使用消息超时时间+死信队列，前面已经演示过了</p><h1 id="2-延迟插件"><a href="#2-延迟插件" class="headerlink" title="2 延迟插件"></a>2 延迟插件</h1><h2 id="一、插件简介"><a href="#一、插件简介" class="headerlink" title="一、插件简介"></a>一、插件简介</h2><ul><li>官网地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></li><li>延迟极限：最多两天</li></ul><h2 id="二、插件安装"><a href="#二、插件安装" class="headerlink" title="二、插件安装"></a>二、插件安装</h2><h3 id="1、确定卷映射目录"><a href="#1、确定卷映射目录" class="headerlink" title="1、确定卷映射目录"></a>1、确定卷映射目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect rabbitmq<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;Mounts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;volume&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rabbitmq-plugin&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/docker/volumes/rabbitmq-plugin/_data&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/plugins&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Mode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;RW&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Propagation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;volume&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/docker/volumes/cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11/_data&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/rabbitmq&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Mode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;RW&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Propagation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>和容器内&#x2F;plugins目录对应的宿主机目录是：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;rabbitmq-plugin&#x2F;_data</p><h3 id="2、下载延迟插件"><a href="#2、下载延迟插件" class="headerlink" title="2、下载延迟插件"></a>2、下载延迟插件</h3><p>官方文档说明页地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20231107180045135.png" alt="image-20231107180045135"></p><p>下载插件安装文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.13.0/rabbitmq_delayed_message_exchange-3.13.0.ez<br>mv rabbitmq_delayed_message_exchange-3.13.0.ez /var/lib/docker/volumes/rabbitmq-plugin/_data<br></code></pre></td></tr></table></figure><h3 id="3、启用插件"><a href="#3、启用插件" class="headerlink" title="3、启用插件"></a>3、启用插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">登录进入容器内部</span><br>docker exec -it rabbitmq /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rabbitmq-plugins命令所在目录已经配置到<span class="hljs-variable">$PATH</span>环境变量中了，可以直接调用</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出Docker容器</span><br>exit<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启Docker容器</span><br>docker restart rabbitmq<br></code></pre></td></tr></table></figure><h3 id="4、确认"><a href="#4、确认" class="headerlink" title="4、确认"></a>4、确认</h3><p>确认点1：查看当前节点已启用插件的列表：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240321115348525.png" alt="image-20240321115348525"></p><p>确认点2：如果创建新交换机时可以在type中看到x-delayed-message选项，那就说明插件安装好了</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20231107181914265.png" alt="image-20231107181914265"></p><h2 id="三、创建交换机"><a href="#三、创建交换机" class="headerlink" title="三、创建交换机"></a>三、创建交换机</h2><p>rabbitmq_delayed_message_exchange插件在工作时要求交换机是<span style="color:blue;font-weight:bolder;">x-delayed-message</span>类型才可以，创建方式如下：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240319163915574.png" alt="image-20240319163915574"></p><p>关于<span style="color:blue;font-weight:bolder;">x-delayed-type</span>参数的理解：</p><blockquote><p>原本指定交换机类型的地方使用了x-delayed-message这个值，那么这个交换机除了支持延迟消息之外，到底是direct、fanout、topic这些类型中的哪一个呢？</p><p>这里就额外使用x-delayed-type来指定交换机本身的类型</p></blockquote><h2 id="四、代码测试"><a href="#四、代码测试" class="headerlink" title="四、代码测试"></a>四、代码测试</h2><h3 id="1、生产者端代码"><a href="#1、生产者端代码" class="headerlink" title="1、生产者端代码"></a>1、生产者端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDelayMessage</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(<br>            EXCHANGE_DELAY,<br>            ROUTING_KEY_DELAY,<br>            <span class="hljs-string">&quot;测试基于插件的延迟消息 [&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;hh:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) + <span class="hljs-string">&quot;]&quot;</span>,<br>            messageProcessor -&gt; &#123;<br><br>                <span class="hljs-comment">// 设置延迟时间：以毫秒为单位</span><br>                messageProcessor.getMessageProperties().setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-string">&quot;10000&quot;</span>);<br><br>                <span class="hljs-keyword">return</span> messageProcessor;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、消费者端代码"><a href="#2、消费者端代码" class="headerlink" title="2、消费者端代码"></a>2、消费者端代码</h3><h4 id="①情况A：资源已创建"><a href="#①情况A：资源已创建" class="headerlink" title="①情况A：资源已创建"></a>①情况A：资源已创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;  <br>  <br><span class="hljs-meta">@Component</span>  <br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDelayMessageListener</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.delay.video&quot;</span>;<br>    <br>    <span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_DELAY&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        log.info(<span class="hljs-string">&quot;[生产者]&quot;</span> + dataString);<br>        log.info(<span class="hljs-string">&quot;[消费者]&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;hh:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②情况B：资源未创建"><a href="#②情况B：资源未创建" class="headerlink" title="②情况B：资源未创建"></a>②情况B：资源未创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;  <br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;  <br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.*;  <br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;  <br><br><span class="hljs-keyword">import</span> java.io.IOException;  <br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;  <br><span class="hljs-keyword">import</span> java.util.Date;  <br>  <br><span class="hljs-meta">@Component</span>  <br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDelayMessageListener</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.delay.video&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;routing.key.delay.video&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.delay.video&quot;</span>;<br>  <br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(  </span><br><span class="hljs-meta">        value = @Queue(value = QUEUE_DELAY, durable = &quot;true&quot;, autoDelete = &quot;false&quot;),  </span><br><span class="hljs-meta">        exchange = @Exchange(  </span><br><span class="hljs-meta">                value = EXCHANGE_DELAY,   </span><br><span class="hljs-meta">                durable = &quot;true&quot;,   </span><br><span class="hljs-meta">                autoDelete = &quot;false&quot;,   </span><br><span class="hljs-meta">                type = &quot;x-delayed-message&quot;,   </span><br><span class="hljs-meta">                arguments = @Argument(name = &quot;x-delayed-type&quot;, value = &quot;direct&quot;)),  </span><br><span class="hljs-meta">        key = &#123;ROUTING_KEY_DELAY&#125;  </span><br><span class="hljs-meta">    ))</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        log.info(<span class="hljs-string">&quot;[生产者]&quot;</span> + dataString);  <br>        log.info(<span class="hljs-string">&quot;[消费者]&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;hh:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));  <br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);  <br>    &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、执行效果"><a href="#3、执行效果" class="headerlink" title="3、执行效果"></a>3、执行效果</h3><h4 id="①交换机类型"><a href="#①交换机类型" class="headerlink" title="①交换机类型"></a>①交换机类型</h4><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240319171359652.png" alt="image-20240319171359652"></p><h4 id="②生产者端效果"><a href="#②生产者端效果" class="headerlink" title="②生产者端效果"></a>②生产者端效果</h4><p><span style="color:blue;font-weight:bolder;">注意</span>：使用rabbitmq_delayed_message_exchange插件后，即使消息成功发送到队列上，也会导致returnedMessage()方法执行</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240321115605608.png" alt="image-20240321115605608"></p><h4 id="③消费者端效果"><a href="#③消费者端效果" class="headerlink" title="③消费者端效果"></a>③消费者端效果</h4><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC9%E7%AB%A0%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/image-20240321115646548.png" alt="image-20240321115646548"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-什么是死信队列"><a href="#1-1-什么是死信队列" class="headerlink" title="1.1 什么是死信队列"></a>1.1 什么是死信队列</h2><p>死信队列，英文缩写：DLX 。DeadLetter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20240806095014641.png" alt="image-20240806095014641"></p><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer将消息投递到broker或者直接到queue里了，consumer从queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；</p><h2 id="1-2-消息成为死信的三种情况"><a href="#1-2-消息成为死信的三种情况" class="headerlink" title="1.2 消息成为死信的三种情况"></a>1.2 <strong>消息成为死信的三种情况</strong></h2><ul><li><strong>拒绝：</strong>消费者拒接消息，basicNack()&#x2F;basicReject()，并且不把消息重新放入原目标队列，requeue&#x3D;false</li><li><strong>溢出：</strong>队列中消息数量到达限制。比如队列最大只能存储10条消息，且现在已经存储了10条，此时如果再发送一条消息进来，根据先进先出原则，队列中最早的消息会变成死信</li><li><strong>超时：</strong>消息到达超时时间未被消费</li></ul><h2 id="1-3-死信的处理方式"><a href="#1-3-死信的处理方式" class="headerlink" title="1.3 死信的处理方式"></a>1.3 死信的处理方式</h2><p>死信的产生既然不可避免，那么就需要从实际的业务角度和场景出发，对这些死信进行后续的处理，常见的处理方式大致有下面几种，</p><p><strong>① 丢弃，</strong>如果不是很重要，可以选择丢弃</p><p><strong>② 记录死信入库，</strong>然后做后续的业务分析或处理</p><p><strong>③ 通过死信队列，</strong>由负责监听死信的应用程序进行处理</p><p>综合来看，更常用的做法是第三种，即通过死信队列，将产生的死信通过程序的配置路由到指定的死信队列，然后应用监听死信队列，对接收到的死信做后续的处理，</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h1><h2 id="一、测试相关准备"><a href="#一、测试相关准备" class="headerlink" title="一、测试相关准备"></a>一、测试相关准备</h2><h3 id="1、创建死信交换机和死信队列"><a href="#1、创建死信交换机和死信队列" class="headerlink" title="1、创建死信交换机和死信队列"></a>1、创建死信交换机和死信队列</h3><p>常规设定即可，没有特殊设置：</p><ul><li>死信交换机：exchange.dead.letter.video</li><li>死信队列：queue.dead.letter.video</li><li>死信路由键：routing.key.dead.letter.video</li></ul><h3 id="2、创建正常交换机和正常队列"><a href="#2、创建正常交换机和正常队列" class="headerlink" title="2、创建正常交换机和正常队列"></a>2、创建正常交换机和正常队列</h3><p><span style="color:blue;font-weight:bolder;">注意</span>：一定要注意正常队列有诸多限定和设置，这样才能让无法处理的消息进入死信交换机</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20240318165821774.png" alt="image-20240318165821774"></p><ul><li>正常交换机：exchange.normal.video</li><li>正常队列：queue.normal.video</li><li>正常路由键：routing.key.normal.video</li></ul><p>全部设置完成后参照如下细节：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20240318165927279.png" alt="image-20240318165927279"></p><h3 id="3、Java代码中的相关常量声明"><a href="#3、Java代码中的相关常量声明" class="headerlink" title="3、Java代码中的相关常量声明"></a>3、Java代码中的相关常量声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.normal.video&quot;</span>;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DEAD_LETTER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.dead.letter.video&quot;</span>;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;routing.key.normal.video&quot;</span>;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_DEAD_LETTER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;routing.key.dead.letter.video&quot;</span>;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.normal.video&quot;</span>;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DEAD_LETTER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.dead.letter.video&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="二、消费端拒收消息"><a href="#二、消费端拒收消息" class="headerlink" title="二、消费端拒收消息"></a>二、消费端拒收消息</h2><h3 id="1、发送消息的代码"><a href="#1、发送消息的代码" class="headerlink" title="1、发送消息的代码"></a>1、发送消息的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageButReject</span><span class="hljs-params">()</span> &#123;  <br>    rabbitTemplate  <br>            .convertAndSend(  <br>                    EXCHANGE_NORMAL,  <br>                    ROUTING_KEY_NORMAL,  <br>                    <span class="hljs-string">&quot;测试死信情况1：消息被拒绝&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、接收消息的代码"><a href="#2、接收消息的代码" class="headerlink" title="2、接收消息的代码"></a>2、接收消息的代码</h3><h4 id="①监听正常队列"><a href="#①监听正常队列" class="headerlink" title="①监听正常队列"></a>①监听正常队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_NORMAL&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessageNormal</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 监听正常队列，但是拒绝消息</span><br>    log.info(<span class="hljs-string">&quot;★[normal]消息接收到，但我拒绝。&quot;</span>);<br>    channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②监听死信队列"><a href="#②监听死信队列" class="headerlink" title="②监听死信队列"></a>②监听死信队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_DEAD_LETTER&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessageDead</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>    <span class="hljs-comment">// 监听死信队列  </span><br>    log.info(<span class="hljs-string">&quot;★[dead letter]dataString = &quot;</span> + dataString);<br>    log.info(<span class="hljs-string">&quot;★[dead letter]我是死信监听方法，我接收到了死信消息&quot;</span>);<br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、执行结果"><a href="#3、执行结果" class="headerlink" title="3、执行结果"></a>3、执行结果</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20231107170523503.png" alt="image-20231107170523503"></p><h2 id="三、消息数量超过队列容纳极限"><a href="#三、消息数量超过队列容纳极限" class="headerlink" title="三、消息数量超过队列容纳极限"></a>三、消息数量超过队列容纳极限</h2><h3 id="1、发送消息的代码-1"><a href="#1、发送消息的代码-1" class="headerlink" title="1、发送消息的代码"></a>1、发送消息的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMultiMessage</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;  <br>        rabbitTemplate.convertAndSend(  <br>                EXCHANGE_NORMAL,  <br>                ROUTING_KEY_NORMAL,  <br>                <span class="hljs-string">&quot;测试死信情况2：消息数量超过队列的最大容量&quot;</span> + i);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、接收消息的代码-1"><a href="#2、接收消息的代码-1" class="headerlink" title="2、接收消息的代码"></a>2、接收消息的代码</h3><p>消息接收代码不再拒绝消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_NORMAL&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessageNormal</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 监听正常队列</span><br>    log.info(<span class="hljs-string">&quot;★[normal]消息接收到。&quot;</span>);<br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重启微服务使代码修改生效。</p><h3 id="3、执行效果"><a href="#3、执行效果" class="headerlink" title="3、执行效果"></a>3、执行效果</h3><p>正常队列的参数如下图所示：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20231107171231765.png" alt="image-20231107171231765"></p><p>生产者发送20条消息之后，消费端死信队列接收到前10条消息：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/img87.png" alt="images"></p><h2 id="四、消息超时未消费"><a href="#四、消息超时未消费" class="headerlink" title="四、消息超时未消费"></a>四、消息超时未消费</h2><h3 id="1、发送消息的代码-2"><a href="#1、发送消息的代码-2" class="headerlink" title="1、发送消息的代码"></a>1、发送消息的代码</h3><p>正常发送一条消息即可，所以使用第一个例子的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageTimeout</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate<br>            .convertAndSend(<br>                    EXCHANGE_NORMAL,<br>                    ROUTING_KEY_NORMAL,<br>                    <span class="hljs-string">&quot;测试死信情况3：消息超时&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、执行效果"><a href="#2、执行效果" class="headerlink" title="2、执行效果"></a>2、执行效果</h3><p>队列参数生效：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20231107172002297.png" alt="image-20231107172002297"></p><p>因为没有消费端监听程序，所以消息未超时前滞留在队列中：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20231107172234849.png" alt="image-20231107172234849"></p><p>消息超时后，进入死信队列：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC8%E7%AB%A0%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/image-20231107172042460.png" alt="image-20231107172042460"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="消息超时"><a href="#消息超时" class="headerlink" title="消息超时"></a>消息超时</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>TTL 全称 Time To Live（存活时间&#x2F;过期时间）。</p><p>当消息到达存活时间后，还没有被消费，会被自动清除。</p><p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/image-20240806094631068.png" alt="image-20240806094631068"></p><h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2 具体实现"></a>2 具体实现</h1><h2 id="一、队列层面设置"><a href="#一、队列层面设置" class="headerlink" title="一、队列层面设置"></a>一、队列层面设置</h2><h3 id="1、设置"><a href="#1、设置" class="headerlink" title="1、设置"></a>1、设置</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/image-20231107162548129.png" alt="image-20231107162548129"></p><p>别忘了设置绑定关系：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/image-20231107162705883.png" alt="image-20231107162705883"></p><h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><ul><li>不启动消费端程序</li><li>向设置了过期时间的队列中发送100条消息</li><li>等10秒后，看是否全部被过期删除</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/image-20231107163052001.png" alt="image-20231107163052001"></p><h2 id="二、消息层面设置"><a href="#二、消息层面设置" class="headerlink" title="二、消息层面设置"></a>二、消息层面设置</h2><h3 id="1、设置-1"><a href="#1、设置-1" class="headerlink" title="1、设置"></a>1、设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;<br><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageTTL</span><span class="hljs-params">()</span> &#123;  <br>  <br>    <span class="hljs-comment">// 1、创建消息后置处理器对象  </span><br>    <span class="hljs-type">MessagePostProcessor</span> <span class="hljs-variable">messagePostProcessor</span> <span class="hljs-operator">=</span> (Message message) -&gt; &#123;  <br>  <br>        <span class="hljs-comment">// 设定 TTL 时间，以毫秒为单位</span><br>        message.getMessageProperties().setExpiration(<span class="hljs-string">&quot;5000&quot;</span>);  <br>  <br>        <span class="hljs-keyword">return</span> message;<br>    &#125;;<br>  <br>    <span class="hljs-comment">// 2、发送消息  </span><br>    rabbitTemplate.convertAndSend(    <br>            EXCHANGE_DIRECT,     <br>            ROUTING_KEY,     <br>            <span class="hljs-string">&quot;Hello atguigu&quot;</span>, messagePostProcessor);    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、查看效果"><a href="#2、查看效果" class="headerlink" title="2、查看效果"></a>2、查看效果</h3><p>这次我们是发送到普通队列上：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC7%E7%AB%A0%20%E6%B6%88%E6%81%AF%E8%B6%85%E6%97%B6/image-20231107163534385.png" alt="image-20231107163534385"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20240806094300945.png" alt="image-20240806094300945"></p><ul><li>生产者发送10000个消息</li><li>消费端并发能力上限：同时处理1000个请求</li><li>设定：</li></ul><p>​每次最多从队列取回1000个请求</p><h1 id="二、生产者端代码"><a href="#二、生产者端代码" class="headerlink" title="二、生产者端代码"></a>二、生产者端代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        rabbitTemplate.convertAndSend(<br>                EXCHANGE_DIRECT,<br>                ROUTING_KEY,<br>                <span class="hljs-string">&quot;Hello atguigu&quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、消费者端代码"><a href="#三、消费者端代码" class="headerlink" title="三、消费者端代码"></a>三、消费者端代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2、正常业务操作</span><br>log.info(<span class="hljs-string">&quot;消费端接收到消息内容：&quot;</span> + dataString);<br><br><span class="hljs-comment">// System.out.println(10 / 0);</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 3、给 RabbitMQ 服务器返回 ACK 确认信息</span><br>channel.basicAck(deliveryTag, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h1><h2 id="1、未使用prefetch"><a href="#1、未使用prefetch" class="headerlink" title="1、未使用prefetch"></a>1、未使用prefetch</h2><ul><li>不要启动消费端程序，如果正在运行就把它停了</li><li>运行生产者端程序发送100条消息</li><li>查看队列中消息的情况：</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107155915253.png" alt="image-20231107155915253"></p><ul><li><p>说明：</p><ul><li>Ready表示已经发送到队列的消息数量</li><li>Unacked表示已经发送到消费端但是消费端尚未返回ACK信息的消息数量</li><li>Total未被删除的消息总数</li></ul></li><li><p>接下来启动消费端程序，再查看队列情况：</p></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107160233539.png" alt="image-20231107160233539"></p><ul><li>能看到消息全部被消费端取走了，正在逐个处理、确认，说明有多少消息消费端就并发处理多少</li></ul><h2 id="2、设定prefetch"><a href="#2、设定prefetch" class="headerlink" title="2、设定prefetch"></a>2、设定prefetch</h2><h3 id="①YAML配置"><a href="#①YAML配置" class="headerlink" title="①YAML配置"></a>①YAML配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 设置每次最多从消息队列服务器取回多少消息</span><br></code></pre></td></tr></table></figure><h3 id="②测试流程"><a href="#②测试流程" class="headerlink" title="②测试流程"></a>②测试流程</h3><ul><li>停止消费端程序</li><li>运行生产者端程序发送100条消息</li><li>查看队列中消息的情况：</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107160820062.png" alt="image-20231107160820062"></p><ul><li>接下来启动消费端程序，持续观察队列情况：</li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107160922632.png" alt="image-20231107160922632"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107160936216.png" alt="image-20231107160936216"></p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC6%E7%AB%A0%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81/image-20231107160951639.png" alt="image-20231107160951639"></p><ul><li>能看到消息不是一次性全部取回的，而是有个过程</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC5%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC5%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="消息百分百成功投递"><a href="#消息百分百成功投递" class="headerlink" title="消息百分百成功投递"></a>消息百分百成功投递</h1><h1 id="1-消息百分百成功投递"><a href="#1-消息百分百成功投递" class="headerlink" title="1 消息百分百成功投递"></a>1 消息百分百成功投递</h1><p>谈到消息的可靠性投递，无法避免的，在实际的工作中会经常碰到，比如一些核心业务需要保障消息不丢失，接下来我们看一个可靠性投递的流程图，说明可靠性投递的概念：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC5%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92/wps1-17229105587141.jpg" alt="img"> </p><p>Step 1： 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里（或者另外一个同源数据库的消息记录表）</p><p>Step 2：发送消息到MQ Broker节点（采用confirm方式发送，会有异步的返回结果）</p><p>Step 3、4：生产者端接受MQ Broker节点返回的Confirm确认消息结果，然后进行更新消息记录表里的消息状态。比如默认Status &#x3D; 0 当收到消息确认成功后，更新为1即可！</p><p>Step 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status &#x3D; 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）</p><p>Step 6：接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败</p><p>Step 7：我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status &#x3D; 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p><h1 id="2-消息幂等性保障"><a href="#2-消息幂等性保障" class="headerlink" title="2 消息幂等性保障"></a>2 消息幂等性保障</h1><p>幂等性指一次和多次请求某一个资源,对于资源本身应该具有同样的结果。也就是说,其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC5%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92/wps2-17229106077093.jpg" alt="img"> </p><p>在MQ中指,消费多条相同的消息,得到与消费该消息一次相同的结果。</p><p><strong>消息幂等性保障 乐观锁机制</strong></p><p>生产者发送消息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span>,money<span class="hljs-operator">=</span><span class="hljs-number">500</span>,version<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>消费者接收消息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span>,money<span class="hljs-operator">=</span><span class="hljs-number">500</span>,version<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br>id<span class="hljs-operator">=</span><span class="hljs-number">1</span>,money<span class="hljs-operator">=</span><span class="hljs-number">500</span>,version<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>消费者需要保证幂等性：第一次执行SQL语句</p><p>第一次执行：version&#x3D;1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> , version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> version <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>消费者需要保证幂等性：第二次执行SQL语句</p><p>第二次执行：version&#x3D;2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> , version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> version <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/"/>
    <url>/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="消息的可靠性投递"><a href="#消息的可靠性投递" class="headerlink" title="消息的可靠性投递"></a>消息的可靠性投递</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-问题引入"><a href="#1-1-问题引入" class="headerlink" title="1.1 问题引入"></a>1.1 问题引入</h2><ul><li><strong>正常的下单流程</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20240806092424473.png" alt="image-20240806092424473"></p><ul><li><strong>故障情况1：</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20240806092503472.png" alt="image-20240806092503472"></p><p>消息没有发送到消息队列上，后果：消费者拿不到消息，业务功能缺失，数据错误</p><ul><li><strong>故障情况2：</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20240806092558221.png" alt="image-20240806092558221"></p><p>消息成功存入消息队列，但是消息队列服务器宕机了，原本保存在内存中的消息也丢失了，即使服务器重新启动，消息也找不回来了。后果：消费者拿不到消息，业务功能缺失，数据错误</p><ul><li><strong>故障情况3：</strong></li></ul><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20240806092653865.png" alt="image-20240806092653865"></p><p>消息成功存入消息队列，但是消费端出现问题，例如：宕机、抛异常等等。后果：业务功能缺失，数据错误</p><h2 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h2><ul><li><p>故障情况1：消息没有发送到消息队列在生产者端进行确认，具体操作中我们会分别针对交换机和队列来确认，如果没有成功发送到消息队列服务器上，那就可以尝试重新发送</p></li><li><p>故障情况2：消息队列服务器宕机导致内存中消息丢失解决思路：消息持久化到硬盘上，哪怕服务器重启也不会导致消息丢失</p></li><li><p>故障情况3：消费端宕机或抛异常导致消息没有成功被消费消费端消费消息成功，给服务器返回ACK信息，然后消息队列删除该消息消费端消费消息失败，给服务器端返回NACK信息，同时把消息恢复为待消费的状态，这样就可以再次取回消息，重试一次（当然，这就需要消费端接口支持幂等性）</p></li></ul><h1 id="2-故障1解决：生产者端消息确认机制"><a href="#2-故障1解决：生产者端消息确认机制" class="headerlink" title="2 故障1解决：生产者端消息确认机制"></a>2 故障1解决：生产者端消息确认机制</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li>在使用 RabbitMQ 的时候，作为消息发送方希望<strong>杜绝任何消息丢失</strong>或者<strong>投递失败</strong>场景。RabbitMQ 为我们提供了<strong>两种方式</strong>用来<strong>控制消息的投递可靠性模式</strong>。</li></ul><p><strong>·</strong> <strong>confirm 确认模式</strong></p><p><strong>·</strong> <strong>return 退回模式</strong></p><ul><li><strong>rabbitmq 整个消息投递的路径为：</strong></li></ul><p>producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer</p><p><strong>·</strong> 消息从 producer 到 exchange 则会返回一个 confirmCallback 。</p><p><strong>·</strong> 消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback 。</p><p>我们将利用这两个 callback 控制消息的可靠性投递</p><h2 id="二、创建module"><a href="#二、创建module" class="headerlink" title="二、创建module"></a>二、创建module</h2><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/img77.png" alt="images"></p><h2 id="三、搭建环境"><a href="#三、搭建环境" class="headerlink" title="三、搭建环境"></a>三、搭建环境</h2><h3 id="1、配置POM"><a href="#1、配置POM" class="headerlink" title="1、配置POM"></a>1、配置POM</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、主启动类"><a href="#2、主启动类" class="headerlink" title="2、主启动类"></a>2、主启动类</h3><p>没有特殊设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq;  <br>  <br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;  <br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;  <br>  <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQProducerMainType</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitMQProducerMainType.class, args);  <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、YAML"><a href="#3、YAML" class="headerlink" title="3、YAML"></a>3、YAML</h3><p><span style="color:blue;font-weight:bold;">注意</span>：publisher-confirm-type和publisher-returns是两个必须要增加的配置，如果没有则本节功能不生效</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">CORRELATED</span> <span class="hljs-comment"># 交换机的确认</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 队列的确认</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.atguigu.mq.config.MQProducerAckConfig:</span> <span class="hljs-string">info</span><br></code></pre></td></tr></table></figure><h2 id="四、创建配置类"><a href="#四、创建配置类" class="headerlink" title="四、创建配置类"></a>四、创建配置类</h2><h3 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h3><p>在这里我们为什么要创建这个配置类呢？首先，我们需要声明回调函数来接收RabbitMQ服务器返回的确认信息：</p><table><thead><tr><th>方法名</th><th>方法功能</th><th>所属接口</th><th>接口所属类</th></tr></thead><tbody><tr><td>confirm()</td><td>确认消息是否发送到交换机</td><td>ConfirmCallback</td><td>RabbitTemplate</td></tr><tr><td>returnedMessage()</td><td>确认消息是否发送到队列</td><td>ReturnsCallback</td><td>RabbitTemplate</td></tr></tbody></table><p>然后，就是对RabbitTemplate的功能进行增强，因为回调函数所在对象必须设置到RabbitTemplate对象中才能生效。</p><p>原本RabbitTemplate对象并没有生产者端消息确认的功能，要给它设置对应的组件才可以。</p><p>而设置对应的组件，需要调用RabbitTemplate对象下面两个方法：</p><table><thead><tr><th>设置组件调用的方法</th><th>所需对象类型</th></tr></thead><tbody><tr><td>setConfirmCallback()</td><td>ConfirmCallback接口类型</td></tr><tr><td>setReturnCallback()</td><td>ReturnCallback接口类型</td></tr></tbody></table><h3 id="2、API说明"><a href="#2、API说明" class="headerlink" title="2、API说明"></a>2、API说明</h3><h4 id="①ConfirmCallback接口"><a href="#①ConfirmCallback接口" class="headerlink" title="①ConfirmCallback接口"></a>①ConfirmCallback接口</h4><p>这是RabbitTemplate内部的一个接口，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A callback for publisher confirmations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfirmCallback</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Confirmation callback.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> correlationData correlation data for the callback.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ack true for ack, false for nack</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cause An optional cause, for nack, when available, otherwise null.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, <span class="hljs-meta">@Nullable</span> String cause)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者端发送消息之后，回调confirm()方法</p><ul><li>ack参数值为true：表示消息成功发送到了交换机</li><li>ack参数值为false：表示消息没有发送到交换机</li></ul><h4 id="②ReturnCallback接口"><a href="#②ReturnCallback接口" class="headerlink" title="②ReturnCallback接口"></a>②ReturnCallback接口</h4><p>同样也RabbitTemplate内部的一个接口，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A callback for returned messages.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2.3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnsCallback</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returned message callback.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> returned the returned message and metadata.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:blue;font-weight:bold;">注意</span>：接口中的returnedMessage()方法<span style="color:blue;font-weight:bold;font-size:25px;">仅</span>在消息<span style="color:blue;font-weight:bold;font-size:25px;">没有</span>发送到队列时调用</p><p>ReturnedMessage类中主要属性含义如下：</p><table><thead><tr><th>属性名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>message</td><td>org.springframework.amqp.core.Message</td><td>消息以及消息相关数据</td></tr><tr><td>replyCode</td><td>int</td><td>应答码，类似于HTTP响应状态码</td></tr><tr><td>replyText</td><td>String</td><td>应答码说明</td></tr><tr><td>exchange</td><td>String</td><td>交换机名称</td></tr><tr><td>routingKey</td><td>String</td><td>路由键名称</td></tr></tbody></table><h3 id="3、配置类代码"><a href="#3、配置类代码" class="headerlink" title="3、配置类代码"></a>3、配置类代码</h3><h4 id="①要点1"><a href="#①要点1" class="headerlink" title="①要点1"></a>①要点1</h4><p>加@Component注解，加入IOC容器</p><h4 id="②要点2"><a href="#②要点2" class="headerlink" title="②要点2"></a>②要点2</h4><p>配置类自身实现ConfirmCallback、ReturnCallback这两个接口，然后通过this指针把配置类的对象设置到RabbitTemplate对象中。</p><p>操作封装到了一个专门的void init()方法中。</p><p>为了保证这个void init()方法在应用启动时被调用，我们使用@PostConstruct注解来修饰这个方法。</p><p>关于@PostConstruct注解大家可以参照以下说明：</p><blockquote><p>@PostConstruct注解是<span style="color:blue;font-weight:bolder;">Java中的一个标准注解</span>，它用于指定在<span style="color:blue;font-weight:bolder;">对象创建之后立即执行</span>的方法。当使用依赖注入（如Spring框架）或者其他方式创建对象时，@PostConstruct注解可以确保在对象完全初始化之后，执行相应的方法。</p><p>使用@PostConstruct注解的方法必须满足以下条件：</p><ol><li><span style="color:blue;font-weight:bolder;">方法不能有任何参数</span>。</li><li><span style="color:blue;font-weight:bolder;">方法必须是非静态的</span>。</li><li><span style="color:blue;font-weight:bolder;">方法不能返回任何值</span>。</li></ol><p>当容器实例化一个带有@PostConstruct注解的Bean时，它会在<span style="color:blue;font-weight:bolder;">调用构造函数之后</span>，并在<span style="color:blue;font-weight:bolder;">依赖注入完成之前</span>调用被@PostConstruct注解标记的方法。这样，我们可以在该方法中进行一些初始化操作，比如读取配置文件、建立数据库连接等。</p></blockquote><h4 id="③代码"><a href="#③代码" class="headerlink" title="③代码"></a>③代码</h4><p>有了以上说明，下面我们就可以展示配置类的整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.config;<br><br><span class="hljs-keyword">import</span> jakarta.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ReturnedMessage;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQProducerAckConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ack) &#123;<br>            log.info(<span class="hljs-string">&quot;消息发送到交换机成功！数据：&quot;</span> + correlationData);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;消息发送到交换机失败！数据：&quot;</span> + correlationData + <span class="hljs-string">&quot; 原因：&quot;</span> + cause);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消息主体: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returned.getMessage().getBody()));<br>        log.info(<span class="hljs-string">&quot;应答码: &quot;</span> + returned.getReplyCode());<br>        log.info(<span class="hljs-string">&quot;描述：&quot;</span> + returned.getReplyText());<br>        log.info(<span class="hljs-string">&quot;消息使用的交换器 exchange : &quot;</span> + returned.getExchange());<br>        log.info(<span class="hljs-string">&quot;消息使用的路由键 routing : &quot;</span> + returned.getRoutingKey());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、发送消息"><a href="#五、发送消息" class="headerlink" title="五、发送消息"></a>五、发送消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.test;<br>  <br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.order&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order&quot;</span>;<br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> &#123;  <br>        rabbitTemplate.convertAndSend(  <br>                EXCHANGE_DIRECT,   <br>                ROUTING_KEY,   <br>                <span class="hljs-string">&quot;Hello atguigu&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>通过调整代码，测试如下三种情况：</p><ul><li>交换机正确、路由键正确</li><li>交换机正确、路由键不正确，无法发送到队列</li><li>交换机不正确，无法发送到交换机</li></ul><h1 id="3-故障2解决：交换机和队列持久化"><a href="#3-故障2解决：交换机和队列持久化" class="headerlink" title="3 故障2解决：交换机和队列持久化"></a>3 故障2解决：交换机和队列持久化</h1><h2 id="一、测试非持久化交换机和队列"><a href="#一、测试非持久化交换机和队列" class="headerlink" title="一、测试非持久化交换机和队列"></a>一、测试非持久化交换机和队列</h2><h3 id="1、创建非持久化交换机"><a href="#1、创建非持久化交换机" class="headerlink" title="1、创建非持久化交换机"></a>1、创建非持久化交换机</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106192621173.png" alt="image-20231106192621173"></p><p>创建之后，可以在列表中看到：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106192708597.png" alt="image-20231106192708597"></p><h3 id="2、创建非持久化队列"><a href="#2、创建非持久化队列" class="headerlink" title="2、创建非持久化队列"></a>2、创建非持久化队列</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106195216265.png" alt="image-20231106195216265"></p><p>创建之后，可以在列表中看到：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106195132627.png" alt="image-20231106195132627"></p><h3 id="3、绑定"><a href="#3、绑定" class="headerlink" title="3、绑定"></a>3、绑定</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106195748319.png" alt="image-20231106195748319"></p><h3 id="4、发送消息"><a href="#4、发送消息" class="headerlink" title="4、发送消息"></a>4、发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_TRANSIENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.transient.user&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY_TRANSIENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user&quot;</span>;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessageTransient</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.convertAndSend(<br>            EXCHANGE_TRANSIENT,<br>            ROUTING_KEY_TRANSIENT,<br>            <span class="hljs-string">&quot;Hello atguigu user~~~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、查看已发送消息"><a href="#5、查看已发送消息" class="headerlink" title="5、查看已发送消息"></a>5、查看已发送消息</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106200245531.png" alt="image-20231106200245531"></p><p>结论：临时性的交换机和队列也能够接收消息，但如果RabbitMQ服务器重启之后会怎么样呢？</p><h3 id="6、重启RabbitMQ服务器"><a href="#6、重启RabbitMQ服务器" class="headerlink" title="6、重启RabbitMQ服务器"></a>6、重启RabbitMQ服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart rabbitmq<br></code></pre></td></tr></table></figure><p>重启之后，刚才临时性的交换机和队列都没了。在交换机和队列这二者中，队列是消息存储的容器，队列没了，消息就也跟着没了。</p><h2 id="二、持久化的交换机和队列"><a href="#二、持久化的交换机和队列" class="headerlink" title="二、持久化的交换机和队列"></a>二、持久化的交换机和队列</h2><p>我们其实不必专门创建持久化的交换机和队列，因为它们默认就是持久化的。接下来我们只需要确认一下：存放到队列中，尚未被消费端取走的消息，是否会随着RabbitMQ服务器重启而丢失？</p><h3 id="1、发送消息"><a href="#1、发送消息" class="headerlink" title="1、发送消息"></a>1、发送消息</h3><p>运行以前的发送消息方法即可，不过要关掉消费端程序</p><h3 id="2、在管理界面查看消息"><a href="#2、在管理界面查看消息" class="headerlink" title="2、在管理界面查看消息"></a>2、在管理界面查看消息</h3><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106200934265.png" alt="image-20231106200934265"></p><h3 id="3、重启RabbitMQ服务器"><a href="#3、重启RabbitMQ服务器" class="headerlink" title="3、重启RabbitMQ服务器"></a>3、重启RabbitMQ服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart rabbitmq<br></code></pre></td></tr></table></figure><h3 id="4、再次查看消息"><a href="#4、再次查看消息" class="headerlink" title="4、再次查看消息"></a>4、再次查看消息</h3><p>仍然还在：</p><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/image-20231106201123268.png" alt="image-20231106201123268"></p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>在后台管理界面创建交换机和队列时，默认就是持久化的模式。</p><p>此时消息也是持久化的，不需要额外设置。</p><h1 id="4-故障3解决：消费端消息确认"><a href="#4-故障3解决：消费端消息确认" class="headerlink" title="4 故障3解决：消费端消息确认"></a>4 故障3解决：消费端消息确认</h1><h2 id="一、ACK"><a href="#一、ACK" class="headerlink" title="一、ACK"></a>一、ACK</h2><p>ACK是acknowledge的缩写，表示已确认</p><h2 id="二、默认情况"><a href="#二、默认情况" class="headerlink" title="二、默认情况"></a>二、默认情况</h2><p>默认情况下，消费端取回消息后，默认会自动返回ACK确认消息，所以在前面的测试中消息被消费端消费之后，RabbitMQ得到ACK确认信息就会删除消息</p><p>但实际开发中，消费端根据消息队列投递的消息执行对应的业务，未必都能执行成功，如果希望能够多次重试，那么默认设定就不满足要求了</p><p>所以还是要修改成手动确认</p><h2 id="三、创建消费端module"><a href="#三、创建消费端module" class="headerlink" title="三、创建消费端module"></a>三、创建消费端module</h2><h3 id="1、配置POM-1"><a href="#1、配置POM-1" class="headerlink" title="1、配置POM"></a>1、配置POM</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、YAML"><a href="#2、YAML" class="headerlink" title="2、YAML"></a>2、YAML</h3><p>增加针对监听器的设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.100</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span> <span class="hljs-comment"># 把消息确认模式改为手动确认</span><br></code></pre></td></tr></table></figure><h3 id="3、主启动类"><a href="#3、主启动类" class="headerlink" title="3、主启动类"></a>3、主启动类</h3><p>没有特殊设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConsumerMainType</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitMQConsumerMainType.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、消费端监听器"><a href="#四、消费端监听器" class="headerlink" title="四、消费端监听器"></a>四、消费端监听器</h2><h3 id="1、创建监听器类"><a href="#1、创建监听器类" class="headerlink" title="1、创建监听器类"></a>1、创建监听器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.order&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.order&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> &#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、在接收消息的方法上应用注解"><a href="#2、在接收消息的方法上应用注解" class="headerlink" title="2、在接收消息的方法上应用注解"></a>2、在接收消息的方法上应用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修饰监听方法</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">        // 设置绑定关系</span><br><span class="hljs-meta">        bindings = @QueueBinding(</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">            // 配置队列信息：durable 为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除</span><br><span class="hljs-meta">            value = @Queue(value = QUEUE_NAME, durable = &quot;true&quot;, autoDelete = &quot;false&quot;),</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">            // 配置交换机信息：durable 为 true 表示队列持久化；autoDelete 设置为 false 表示关闭自动删除</span><br><span class="hljs-meta">            exchange = @Exchange(value = EXCHANGE_DIRECT, durable = &quot;true&quot;, autoDelete = &quot;false&quot;),</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">            // 配置路由键信息</span><br><span class="hljs-meta">            key = &#123;ROUTING_KEY&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、接收消息方法内部逻辑"><a href="#3、接收消息方法内部逻辑" class="headerlink" title="3、接收消息方法内部逻辑"></a>3、接收消息方法内部逻辑</h3><ul><li>业务处理成功：手动返回ACK信息，表示消息成功消费</li><li>业务处理失败：手动返回NACK信息，表示消息消费失败。此时有两种后续操作供选择：<ul><li>把消息重新放回消息队列，RabbitMQ会重新投递这条消息，那么消费端将重新消费这条消息——从而让业务代码再执行一遍</li><li>不把消息放回消息队列，返回reject信息表示拒绝，那么这条消息的处理就到此为止</li></ul></li></ul><h3 id="4、相关API"><a href="#4、相关API" class="headerlink" title="4、相关API"></a>4、相关API</h3><p>先回到PPT理解“deliveryTag：交付标签机制”</p><p>下面我们探讨的三个方法都是来自于com.rabbitmq.client.<span style="color:blue;font-weight:bolder;">Channel</span>接口</p><h4 id="①basicAck-方法"><a href="#①basicAck-方法" class="headerlink" title="①basicAck()方法"></a>①basicAck()方法</h4><ul><li>方法功能：给Broker返回ACK确认信息，表示消息已经在消费端成功消费，这样Broker就可以把消息删除了</li><li>参数列表：</li></ul><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>long deliveryTag</td><td>Broker给每一条进入队列的消息都设定一个唯一标识</td></tr><tr><td>boolean multiple</td><td>取值为true：为小于、等于deliveryTag的消息批量返回ACK信息<br>取值为false：仅为指定的deliveryTag返回ACK信息</td></tr></tbody></table><h4 id="②basicNack-方法"><a href="#②basicNack-方法" class="headerlink" title="②basicNack()方法"></a>②basicNack()方法</h4><ul><li>方法功能：给Broker返回NACK信息，表示消息在消费端消费失败，此时Broker的后续操作取决于参数requeue的值</li><li>参数列表：</li></ul><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>long deliveryTag</td><td>Broker给每一条进入队列的消息都设定一个唯一标识</td></tr><tr><td>boolean multiple</td><td>取值为true：为小于、等于deliveryTag的消息批量返回ACK信息<br>取值为false：仅为指定的deliveryTag返回ACK信息</td></tr><tr><td>boolean requeue</td><td>取值为true：Broker将消息重新放回队列，接下来会重新投递给消费端<br>取值为false：Broker将消息标记为已消费，不会放回队列</td></tr></tbody></table><h4 id="③basicReject-方法"><a href="#③basicReject-方法" class="headerlink" title="③basicReject()方法"></a>③basicReject()方法</h4><ul><li>方法功能：根据指定的deliveryTag，对该消息表示拒绝</li><li>参数列表：</li></ul><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>long deliveryTag</td><td>Broker给每一条进入队列的消息都设定一个唯一标识</td></tr><tr><td>boolean requeue</td><td>取值为true：Broker将消息重新放回队列，接下来会重新投递给消费端<br>取值为false：Broker将消息标记为已消费，不会放回队列</td></tr></tbody></table><ul><li>basicNack()和basicReject()有啥区别？<ul><li>basicNack()有批量操作</li><li>basicReject()没有批量操作</li></ul></li></ul><h3 id="5、完整代码示例"><a href="#5、完整代码示例" class="headerlink" title="5、完整代码示例"></a>5、完整代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mq.listener;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMessageListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.order&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.order&quot;</span>;<br><br>    <span class="hljs-comment">// 修饰监听方法</span><br>    <span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">            // 设置绑定关系</span><br><span class="hljs-meta">            bindings = @QueueBinding(</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">                // 配置队列信息：durable 为 true 表示队列持久化；autoDelete 为 false 表示关闭自动删除</span><br><span class="hljs-meta">                value = @Queue(value = QUEUE_NAME, durable = &quot;true&quot;, autoDelete = &quot;false&quot;),</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">                // 配置交换机信息：durable 为 true 表示队列持久化；autoDelete 为 false 表示关闭自动删除</span><br><span class="hljs-meta">                exchange = @Exchange(value = EXCHANGE_DIRECT, durable = &quot;true&quot;, autoDelete = &quot;false&quot;),</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">                // 配置路由键信息</span><br><span class="hljs-meta">                key = &#123;ROUTING_KEY&#125;</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String dataString, Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1、获取当前消息的 deliveryTag 值备用</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">deliveryTag</span> <span class="hljs-operator">=</span> message.getMessageProperties().getDeliveryTag();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 2、正常业务操作</span><br>            log.info(<span class="hljs-string">&quot;消费端接收到消息内容：&quot;</span> + dataString);<br>            <br>            <span class="hljs-comment">// System.out.println(10 / 0);</span><br><br>            <span class="hljs-comment">// 3、给 RabbitMQ 服务器返回 ACK 确认信息</span><br>            channel.basicAck(deliveryTag, <span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>            <span class="hljs-comment">// 4、获取信息，看当前消息是否曾经被投递过</span><br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">redelivered</span> <span class="hljs-operator">=</span> message.getMessageProperties().getRedelivered();<br><br>            <span class="hljs-keyword">if</span> (!redelivered) &#123;<br>                <span class="hljs-comment">// 5、如果没有被投递过，那就重新放回队列，重新投递，再试一次</span><br>                channel.basicNack(deliveryTag, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 6、如果已经被投递过，且这一次仍然进入了 catch 块，那么返回拒绝且不再放回队列</span><br>                channel.basicReject(deliveryTag, <span class="hljs-literal">false</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、要点总结"><a href="#五、要点总结" class="headerlink" title="五、要点总结"></a>五、要点总结</h2><ul><li>要点1：把消息确认模式改为<span style="color:blue;font-weight:bold;">手动确认</span></li><li>要点2：调用Channel对象的方法返回信息<ul><li>ACK：Acknowledgement，表示消息处理成功</li><li>NACK：Negative Acknowledgement，表示消息处理失败</li><li>Reject：拒绝，同样表示消息处理失败</li></ul></li><li>要点3：后续操作<ul><li>requeue为true：重新放回队列，重新投递，再次尝试</li><li>requeue为false：不放回队列，不重新投递</li></ul></li><li>要点4：deliveryTag 消息的唯一标识，查找具体某一条消息的依据</li></ul><h2 id="六、流程梳理"><a href="#六、流程梳理" class="headerlink" title="六、流程梳理"></a>六、流程梳理</h2><p><img src="/2024/11/04/RabbitMQ/%E7%AC%AC4%E7%AB%A0%20%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><h2 id="七、多啰嗦一句"><a href="#七、多啰嗦一句" class="headerlink" title="七、多啰嗦一句"></a>七、多啰嗦一句</h2><p>消费端如果设定消息重新放回队列，Broker重新投递消息，那么消费端就可以再次消费消息，这是一种“重试”机制，这需要消费端代码支持“<span style="color:blue;font-weight:bold;">幂等性</span>”——这属于前置知识，不展开了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
